<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Condition Indexer - Experimental</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
        #map { width: 100%; height: 40vh; margin-bottom: 1rem; }
        #map:fullscreen { width: 100%; height: 100%; }
        #status { margin-bottom: 1rem; font-weight: bold; }
        #button-bar { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; }
        #scale-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }
        #scale-bar {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, green, yellow, red);
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<h1>Road Condition Indexer - Experimental</h1>
<div id="status"></div>
<div id="button-bar">
    <button id="toggle">Start</button>
    <button id="gpx-button" style="margin-left:1rem;">Generate GPX</button>
    <button id="update-button" style="margin-left:1rem; display:none;">Update Records</button>
    <button id="fullscreen-button" style="margin-left:1rem;">Fullscreen</button>
    <select id="device-filter" style="margin-left:1rem;" multiple></select>
    <input id="nickname" placeholder="Nickname" style="margin-left:1rem; display:none;" />
    <button id="save-nickname" style="margin-left:0.5rem; display:none;">Save</button>
    <select id="roughness-filter" style="margin-left:1rem;" multiple>
        <option value="">[All Roughness]</option>
        <option>1</option>
        <option>2</option>
        <option>3</option>
        <option>4</option>
        <option>5</option>
        <option>6</option>
        <option>7</option>
        <option>8</option>
        <option>9</option>
        <option>10</option>
    </select>
    <a id="gpx-link" style="display:none; margin-left:1rem;">Download GPX</a>
</div>
<div id="page-links" style="margin-bottom:1rem;">
    <a href="/">Main</a> |
    <a href="device.html">Device View</a> |
    <a href="db.html">DB Page</a> |
    <a href="maintenance.html">Maintenance</a>
</div>
<div id="map"></div>
<div id="scale-container">
    <span>Smooth</span>
    <div id="scale-bar"></div>
    <span>Rough</span>
</div>
<h3>Activity Log</h3>
<div id="log"></div>
<h3>Debug Messages</h3>
<textarea id="debug" readonly></textarea>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let deviceId = localStorage.getItem('deviceId');
let selectedIds = deviceId ? [deviceId] : [];
function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 864e5).toUTCString();
    document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/`;
}
if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem('deviceId', deviceId);
    setCookie('deviceId', deviceId, 365);
}
const userAgent = navigator.userAgent;
const fingerprint = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    navigator.platform,
    new Date().getTimezoneOffset()
].join('|');
const LOG_ENDPOINT = '/experimental_log';

function loadNickname() {
    const nickInput = document.getElementById('nickname');
    if (!nickInput) {
        currentNickname = '';
        return;
    }
    if (selectedIds.length !== 1) {
        nickInput.value = '';
        currentNickname = '';
        return;
    }
    const id = selectedIds[0];
    fetch(`/nickname?device_id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(data => {
            currentNickname = data.nickname || '';
            nickInput.value = currentNickname;
        })
        .catch(console.error);
}

function saveNickname() {
    const nickInput = document.getElementById('nickname');
    if (!nickInput || selectedIds.length !== 1) return;
    const name = nickInput.value;
    fetch('/nickname', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_id: selectedIds[0], nickname: name })
    }).then(() => populateDeviceFilter())
      .catch(console.error);
}

function populateDeviceFilter() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const select = document.getElementById('device-filter');
        select.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        select.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            select.appendChild(opt);
        });
        if (deviceId && !data.ids.some(i => i.id === deviceId)) {
            const opt = document.createElement('option');
            opt.value = deviceId;
            opt.textContent = deviceId;
            select.appendChild(opt);
        }
        Array.from(select.options).forEach(o => {
            if (selectedIds.includes(o.value)) o.selected = true;
        });
        selectedIds = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
    }).then(() => { loadNickname(); loadLogs(); })
      .catch(console.error);
}
let xValues = [];
let yValues = [];
let zValues = [];
let lastLat = 0;
let lastLon = 0;
let lastSpeed = 0;
let lastDir = 0;
let lastRoughness = 0;
let lastAcc = {x:0, y:0, z:0};
let map;
let orientationData = {alpha:0, beta:0, gamma:0};
let roughMin = 0;
let roughMax = 10;
let roughAvg = 0;
let roughScales = {};
let deviceNicknames = {};
let currentNickname = '';
let motionDataReceived = false;
let motionPermissionTimer = null;
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
            orientationData = { alpha: event.alpha || 0, beta: event.beta, gamma: event.gamma };
        }
    });
}

function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(res => addDebug('Motion permission: ' + res))
            .catch(err => addDebug('Motion permission error: ' + err));
    }
}

function checkMotionPermission() {
    if (!motionDataReceived) {
        addDebug('No acceleration data received, requesting permission');
        requestMotionPermission();
        motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    }
}
const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
let geoWatchId = null;
let loggingEnabled = false;
let recordCount = 0;

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        () => addDebug('Geolocation permission granted'),
        err => addDebug('Geolocation permission denied: ' + err.message),
        GEO_OPTIONS
    );
}

function initMap() {
    const defaultPos = [52.028, 5.168]; // Houten, NL
    const zoom = 12;
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const setView = coords => map.setView(coords, zoom);
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => setView([pos.coords.latitude, pos.coords.longitude]),
            () => setView(defaultPos),
            GEO_OPTIONS
        );
    } else {
        setView(defaultPos);
    }
}

function addLog(msg) {
    const div = document.getElementById('log');
    div.textContent += msg + '\n';
    div.scrollTop = div.scrollHeight;
}

function updateStatus() {
    const el = document.getElementById('status');
    el.textContent =
        `Lat: ${lastLat.toFixed(5)}, Lon: ${lastLon.toFixed(5)} | ` +
        `Speed: ${lastSpeed.toFixed(1)} km/h | ` +
        `Dir: ${lastDir.toFixed(0)}\u00B0 | ` +
        `Acc: X: ${lastAcc.x.toFixed(2)} ` +
        `Y: ${lastAcc.y.toFixed(2)} ` +
        `Z: ${lastAcc.z.toFixed(2)} | ` +
        `Roughness: ${lastRoughness.toFixed(2)}`;
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + 10;
        }
    }
    const step = (max - min) / 10;
    if (step <= 0) return '1';
    const idx = Math.max(0, Math.min(9, Math.floor((r - min) / step)));
    return String(idx + 1);
}

function filterRoughness(r) {
    const sel = document.getElementById('roughness-filter');
    if (!sel) return true;
    const values = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (values.length === 0) return true;
    return values.includes(roughnessLabel(r));
}

function zUp(acc) {
    const beta = orientationData.beta * Math.PI / 180;
    const gamma = orientationData.gamma * Math.PI / 180;
    const gX = -Math.sin(beta);
    const gY = Math.cos(beta) * Math.sin(gamma);
    const gZ = Math.cos(beta) * Math.cos(gamma);
    const upX = -gX;
    const upY = -gY;
    const upZ = -gZ;
    const mag = Math.sqrt(upX*upX + upY*upY + upZ*upZ) || 1;
    return (acc.x * upX + acc.y * upY + acc.z * upZ) / mag;
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = new Date(info.timestamp).toLocaleString();
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
    if (info && info.id) {
        marker.on('click', () => {
            localStorage.setItem('selectedRecordId', info.id);
        });
    }
}

function loadLogs() {
    const select = document.getElementById('device-filter');
    const ids = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
    let url = '/logs';
    if (ids.length > 0) {
        const params = new URLSearchParams();
        ids.forEach(id => params.append('device_id', id));
        url = '/filteredlogs?' + params.toString();
    }
    fetch(url).then(r => r.json()).then(data => {
        const rows = Array.isArray(data) ? data : data.rows;
        roughAvg = data.average || 0;
        if (map) {
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
        }
        roughMin = 0;
        roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
        roughScales = {};
        rows.forEach(row => {
            const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
            s.min = Math.min(s.min, row.roughness);
            s.max = Math.max(s.max, row.roughness);
            roughScales[row.device_id] = s;
        });
        rows.reverse().forEach(row => {
            if (!filterRoughness(row.roughness)) return;
            const name = deviceNicknames[row.device_id] || '';
            const scale = roughScales[row.device_id] || {min:0,max:1};
            addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
        });
        addLog(`Total records loaded: ${rows.length}`);
        recordCount = rows.length;
    }).catch(err => console.error(err));
}

function addDebug(msg) {
    const el = document.getElementById('debug');
    el.value += msg + '\n';
    el.scrollTop = el.scrollHeight;
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', (event) => {
        if (event.accelerationIncludingGravity) {
            const acc = event.accelerationIncludingGravity;
            motionDataReceived = true;
            xValues.push(acc.x || 0);
            yValues.push(acc.y || 0);
            const zUpVal = zUp(acc);
            zValues.push(zUpVal);
            lastAcc = { x: acc.x || 0, y: acc.y || 0, z: zUpVal };
            updateStatus();
        }
    });
}

function handlePosition(pos) {
    const { latitude, longitude, speed, heading } = pos.coords;
    lastLat = latitude;
    lastLon = longitude;
    lastSpeed = (speed || 0) * 3.6; // convert to km/h
    lastDir = heading || 0;
    updateStatus();
    addLog(`Location: ${latitude}, ${longitude} speed: ${lastSpeed.toFixed(1)} km/h`);
    if (loggingEnabled && zValues.length > 0) {
        fetch(LOG_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                latitude,
                longitude,
                speed: lastSpeed,
                direction: lastDir,
                z_values: zValues,
                device_id: deviceId,
                user_agent: userAgent,
                device_fp: fingerprint
            })
        }).then(r => r.json()).then(data => {
            if (data.roughness !== undefined) {
                lastRoughness = data.roughness;
                addLog(`Record inserted, roughness: ${data.roughness.toFixed(2)}`);
                updateStatus();
                const scale = roughScales[deviceId] || {min: data.roughness, max: data.roughness};
                if (filterRoughness(data.roughness)) {
                    addPoint(latitude, longitude, data.roughness, {
                        timestamp: new Date().toISOString(),
                        speed: lastSpeed,
                        direction: lastDir,
                        roughness: data.roughness
                    }, currentNickname, scale.min, scale.max);
                }
                scale.min = Math.min(scale.min, data.roughness);
                scale.max = Math.max(scale.max, data.roughness);
                roughScales[deviceId] = scale;
                recordCount += 1;
                loadLogs();
            }
        }).catch(err => addDebug('Error: ' + err));
        xValues = [];
        yValues = [];
        zValues = [];
    }
}

function handleGeoError(err) {
    addDebug('Geolocation error: ' + err.message);
}

function startGeolocation() {
    if (!navigator.geolocation) {
        addDebug('Geolocation not supported');
        return;
    }
    motionDataReceived = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
    }
    requestMotionPermission();
    motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    if (geoWatchId === null) {
        geoWatchId = navigator.geolocation.watchPosition(
            handlePosition,
            handleGeoError,
            GEO_OPTIONS
        );
    }
    loggingEnabled = true;
}

function stopGeolocation() {
    loggingEnabled = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
        motionPermissionTimer = null;
    }
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
    }
}

function pollDebug() {
    fetch('/debuglog').then(r => r.json()).then(data => {
        document.getElementById('debug').value = data.log.join('\n');
    }).catch(console.error).finally(() => setTimeout(pollDebug, 2000));
}

function generateGpx() {
    fetch('/gpx').then(r => r.blob()).then(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.getElementById('gpx-link');
        link.href = url;
        link.download = 'records.gpx';
        link.style.display = 'inline';
        link.textContent = 'Download GPX';
    }).catch(err => addDebug('GPX error: ' + err));
}

updateStatus();
initMap();
populateDeviceFilter();
pollDebug();

document.getElementById('toggle').addEventListener('click', () => {
    if (loggingEnabled) {
        stopGeolocation();
        document.getElementById('toggle').textContent = 'Start';
        addLog('Logging stopped');
    } else {
        startGeolocation();
        document.getElementById('toggle').textContent = 'Stop';
        addLog('Logging started');
    }
});

document.getElementById('gpx-button').addEventListener('click', () => {
    addLog('Generate GPX pressed');
    generateGpx();
});
const updateBtn = document.getElementById('update-button');
if (updateBtn) {
    updateBtn.addEventListener('click', () => {
        addLog('Update Records pressed');
        loadLogs();
    });
}
const saveNickBtn = document.getElementById('save-nickname');
if (saveNickBtn) {
    saveNickBtn.addEventListener('click', () => {
        addLog('Save Nickname pressed');
        saveNickname();
    });
}
document.getElementById('device-filter').addEventListener('change', () => {
    selectedIds = Array.from(document.getElementById('device-filter').selectedOptions)
        .map(o => o.value).filter(v => v);
    loadNickname();
    loadLogs();
});
document.getElementById('roughness-filter').addEventListener('change', () => {
    loadLogs();
});
document.getElementById('fullscreen-button').addEventListener('click', () => {
    const el = document.getElementById('map');
    addLog('Fullscreen button pressed');
    if (!document.fullscreenElement) {
        if (el.requestFullscreen) {
            el.requestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});

let wakeLock = null;
async function requestWakeLock() {
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => addDebug('Wake lock released'));
        addDebug('Wake lock acquired');
    } catch (err) {
        addDebug('Wake lock error: ' + err.message);
    }
}

if ('wakeLock' in navigator) {
    requestWakeLock();
    document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
            requestWakeLock();
        }
    });
}
</script>
<div id="roughness-info" style="margin-top:1rem; border:1px solid #ccc; padding:0.5rem;">
    <strong>Roughness Calculation</strong> - vertical acceleration samples are filtered between 0&nbsp;and&nbsp;20&nbsp;Hz,
    the RMS of the filtered signal is normalised by average speed, and values recorded below
    5&nbsp;km/h are ignored.
</div>
</body>
</html>
