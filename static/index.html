<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Condition Indexer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 1rem; }
        #log, #records {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
        #map { width: 100%; height: 40vh; margin-bottom: 1rem; }
        #status { margin-bottom: 1rem; font-weight: bold; }
    </style>
</head>
<body>
<h1>Road Condition Indexer</h1>
<div id="status"></div>
<h3>Activity Log</h3>
<div id="log"></div>
<h3>Records</h3>
<pre id="records"></pre>
<div id="map"></div>
<h3>Debug Messages</h3>
<textarea id="debug" readonly></textarea>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let xValues = [];
let yValues = [];
let zValues = [];
let lastLat = 0;
let lastLon = 0;
let lastSpeed = 0;
let lastDir = 0;
let lastRoughness = 0;
let lastAcc = {x:0, y:0, z:0};
let map;
const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
const POLL_INTERVAL_MS = 1000; // attempt ~1m updates when moving
let geoPollId = null;
let recordCount = 0;

function initMap() {
    // Show roughly a 10km area around Houten, NL
    map = L.map('map').setView([52.028, 5.168], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
}

function addLog(msg) {
    const div = document.getElementById('log');
    div.textContent += msg + '\n';
    div.scrollTop = div.scrollHeight;
}

function updateStatus() {
    const el = document.getElementById('status');
    el.textContent =
        `Lat: ${lastLat.toFixed(5)}, Lon: ${lastLon.toFixed(5)} | ` +
        `Speed: ${lastSpeed.toFixed(1)} km/h | ` +
        `Dir: ${lastDir.toFixed(0)}\u00B0 | ` +
        `Acc: X: ${lastAcc.x.toFixed(2)} ` +
        `Y: ${lastAcc.y.toFixed(2)} ` +
        `Z: ${lastAcc.z.toFixed(2)} | ` +
        `Roughness: ${lastRoughness.toFixed(2)}`;
}

function colorForRoughness(r) {
    const ratio = Math.min(Math.max(r / 10, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function addMarker(lat, lon, roughness) {
    if (!map) return;
    L.circleMarker([lat, lon], {
        radius: 6,
        color: colorForRoughness(roughness),
        fillColor: colorForRoughness(roughness),
        fillOpacity: 0.8
    }).addTo(map);
}

function loadLogs() {
    fetch('/logs').then(r => r.json()).then(data => {
        const recordEl = document.getElementById('records');
        recordEl.textContent = '';
        if (map) {
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker) {
                    map.removeLayer(layer);
                }
            });
        }
        data.reverse().forEach(row => {
            const { latitude, longitude, roughness, timestamp } = row;
            const timeStr = new Date(timestamp).toLocaleString();
            recordEl.textContent += `${timeStr} - ${latitude}, ${longitude} - roughness ${roughness.toFixed(2)}\n`;
            addMarker(latitude, longitude, roughness);
        });
        addLog(`Total records loaded: ${data.length}`);
        recordCount = data.length;
    }).catch(err => console.error(err));
}

function addDebug(msg) {
    const el = document.getElementById('debug');
    el.value += msg + '\n';
    el.scrollTop = el.scrollHeight;
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', (event) => {
        if (event.accelerationIncludingGravity) {
            const acc = event.accelerationIncludingGravity;
            xValues.push(acc.x || 0);
            yValues.push(acc.y || 0);
            zValues.push(acc.z || 0);
            lastAcc = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
            updateStatus();
        }
    });
}

function handlePosition(pos) {
    const { latitude, longitude, speed, heading } = pos.coords;
    lastLat = latitude;
    lastLon = longitude;
    lastSpeed = (speed || 0) * 3.6; // convert to km/h
    lastDir = heading || 0;
    updateStatus();
    addLog(`Location: ${latitude}, ${longitude} speed: ${lastSpeed.toFixed(1)} km/h`);
    if (zValues.length > 0) {
        fetch('/log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                latitude,
                longitude,
                speed: lastSpeed,
                direction: lastDir,
                z_values: zValues
            })
        }).then(r => r.json()).then(data => {
            if (data.roughness !== undefined) {
                lastRoughness = data.roughness;
                addLog('Roughness: ' + data.roughness.toFixed(2));
                updateStatus();
                addMarker(latitude, longitude, data.roughness);
                recordCount += 1;
            }
        }).catch(err => addDebug('Error: ' + err));
        xValues = [];
        yValues = [];
        zValues = [];
    }
}

function handleGeoError(err) {
    addDebug('Geolocation error: ' + err.message);
}

function startGeolocation() {
    if (!navigator.geolocation) {
        addDebug('Geolocation not supported');
        return;
    }
    navigator.geolocation.watchPosition(handlePosition, handleGeoError, GEO_OPTIONS);
    geoPollId = setInterval(() => {
        navigator.geolocation.getCurrentPosition(handlePosition, handleGeoError, GEO_OPTIONS);
    }, POLL_INTERVAL_MS);
}

function pollDebug() {
    fetch('/debuglog').then(r => r.json()).then(data => {
        document.getElementById('debug').value = data.log.join('\n');
    }).catch(console.error).finally(() => setTimeout(pollDebug, 2000));
}

updateStatus();
initMap();
loadLogs();
pollDebug();
startGeolocation();

let wakeLock = null;
async function requestWakeLock() {
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => addDebug('Wake lock released'));
        addDebug('Wake lock acquired');
    } catch (err) {
        addDebug('Wake lock error: ' + err.message);
    }
}

if ('wakeLock' in navigator) {
    requestWakeLock();
    document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
            requestWakeLock();
        }
    });
}
</script>
</body>
</html>
