<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Condition Indexer</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
    <script src="/static/utils.js"></script>
    <script src="map-components.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
        #status { margin-bottom: 1rem; font-weight: bold; }
        #button-bar { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input:disabled { opacity: 0.5; cursor: not-allowed; }
        select { padding: 0.5rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 4px; }
        #toggle { padding: 0.75rem 1.5rem; font-size: 1.1rem; font-weight: bold; border-radius: 6px; border: 2px solid #ccc; transition: all 0.3s ease; }
        #toggle.recording { 
            background-color: #f44336; 
            color: white; 
            border-color: #d32f2f;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.3);
            animation: pulse-recording 2s infinite;
        }
        #toggle.recording:hover {
            background-color: #d32f2f;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
        }
        #toggle.stopped { 
            background-color: #4CAF50; 
            color: white; 
            border-color: #45a049; 
        }
        #toggle.stopped:hover {
            background-color: #45a049;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }
        @keyframes pulse-recording {
            0% { box-shadow: 0 0 10px rgba(244, 67, 54, 0.3); }
            50% { box-shadow: 0 0 20px rgba(244, 67, 54, 0.6); }
            100% { box-shadow: 0 0 10px rgba(244, 67, 54, 0.3); }
        }
        /* Responsive design for start button */
        @media (max-width: 600px) {
            #toggle {
                font-size: 1rem;
                padding: 0.75rem;
            }
        }
        #status-indicators {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 0.8rem;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            gap: 6px;
        }
        .status-item:last-child {
            margin-bottom: 0;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
        }
        .status-green {
            background-color: #4CAF50;
        }
        .status-red {
            background-color: #f44336;
        }
        /* Settings panel styles */
        #settings-panel {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 1rem 0;
            background: #f9f9f9;
        }
        #settings-header {
            padding: 8px 12px;
            background: #e9e9e9;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #settings-header:hover {
            background: #ddd;
        }
        #settings-content {
            padding: 12px;
            display: none;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .setting-item label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
        }
        .setting-item input {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        .setting-item .help-text {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
        }
        .settings-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            border-top: 1px solid #ddd;
            padding-top: 8px;
            margin-top: 8px;
        }
        .settings-buttons button {
            padding: 6px 12px;
            font-size: 0.85rem;
            border-radius: 3px;
        }
        #settings-save {
            background: #4CAF50;
            color: white;
            border: 1px solid #45a049;
        }
        #settings-save:hover {
            background: #45a049;
        }
        #settings-reset {
            background: #f44336;
            color: white;
            border: 1px solid #d32f2f;
        }
        #settings-reset:hover {
            background: #d32f2f;
        }
        .bicycle-marker {
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        /* Pulse animation for the bicycle marker */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }
        .bicycle-pulse {
            animation: pulse 1.5s infinite ease-in-out;
        }
    </style>
</head>
<body>
<nav id="page-links" style="margin-bottom:1rem;">
    <a href="device.html">Device View</a> |
    <a href="database.html">Database Management</a> |
    <a href="maintenance.html">Maintenance</a> |
    <a href="tools.html">Tools</a> |
    <a href="shared.html">Shared</a>
</nav>
<h1><img src="/static/logo.png" alt="Road Condition Indexer Logo" style="height: 2em; vertical-align: middle; margin-right: 0.5em;">Road Condition Indexer</h1>
<!-- Status indicators in top right -->
<div id="status-indicators">
    <div class="status-item">
        <div id="location-indicator" class="status-indicator status-red"></div>
        <span id="location-text">Location</span>
    </div>
    <div class="status-item">
        <div id="acceleration-indicator" class="status-indicator status-red"></div>
        <span id="motion-text">Motion</span>
    </div>
    <div class="status-item">
        <div id="database-indicator" class="status-indicator status-red"></div>
        <span>Database</span>
    </div>
    <div class="status-item">
        <div id="wakelock-indicator" class="status-indicator status-red"></div>
        <span>Wake Lock</span>
    </div>
    <div class="status-item" style="border-top: 1px solid #ccc; padding-top: 4px; margin-top: 4px;">
        <span id="coordinates-text" style="font-family: monospace; font-size: 0.75rem;">---.-----, ---.-----</span>
    </div>
    <div class="status-item">
        <span id="speed-text" style="font-family: monospace; font-size: 0.75rem;">--- km/h | ---¬∞</span>
    </div>
    <div class="status-item">
        <span id="roughness-text" style="font-family: monospace; font-size: 0.75rem;">R: ---.--</span>
    </div>
</div>
<!-- Hidden maintenance link as a square at bottom right -->
<a href="maintenance.html" id="maintenance-link" style="position:fixed;bottom:24px;right:24px;width:32px;height:32px;display:block;z-index:9999;opacity:0.2;background:#888;border-radius:6px;text-align:center;line-height:32px;text-decoration:none;font-size:1.5rem;transition:opacity 0.2s;" title="Maintenance">üõ†Ô∏è</a>
<script>
// Show the maintenance link on hover or focus
const maintLink = document.getElementById('maintenance-link');
maintLink.addEventListener('mouseenter',()=>maintLink.style.opacity='1');
maintLink.addEventListener('mouseleave',()=>maintLink.style.opacity='0.2');
maintLink.addEventListener('focus',()=>maintLink.style.opacity='1');
maintLink.addEventListener('blur',()=>maintLink.style.opacity='0.2');
</script>
<section id="recording-controls" style="margin-bottom:1rem;">
    <div style="display: flex; justify-content: center; margin-bottom: 0.5rem;">
        <button id="toggle">‚ñ∂Ô∏è Start Recording</button>
    </div>
</section>

<!-- Include standardized map component -->
<div id="map-container"></div>
<div style="margin-bottom:1rem;">
    <label>
        <input type="checkbox" id="center-on-user" checked> Keep map centered on my location
    </label>
    <br>
    <label>
        <input type="checkbox" id="record-source-data" checked> Record source data for retrospective analysis
    </label>
    <div style="font-size: 0.8rem; color: #666; margin-top: 4px; margin-left: 20px;">
        When enabled, stores raw acceleration data for recalculating roughness values later
    </div>
</div>

<!-- Settings Panel -->
<div id="settings-panel">
    <div id="settings-header" onclick="toggleSettings()">
        <span>‚öôÔ∏è Recording Thresholds</span>
        <span id="settings-toggle">‚ñ∂</span>
    </div>
    <div id="settings-content">
        <div class="settings-grid">
            <div class="setting-item">
                <label for="max-interval">Max Time Interval (sec)</label>
                <input type="number" id="max-interval" min="1" max="300" step="1" value="15">
                <div class="help-text">Maximum time between data points before ignoring</div>
            </div>
            <div class="setting-item">
                <label for="max-distance">Max Distance (m)</label>
                <input type="number" id="max-distance" min="10" max="10000" step="10" value="100">
                <div class="help-text">Maximum distance between points before ignoring</div>
            </div>
            <div class="setting-item">
                <label for="min-speed">Min Speed (km/h)</label>
                <input type="number" id="min-speed" min="0" max="200" step="0.1" value="0">
                <div class="help-text">Minimum speed for recording data (0 = no limit)</div>
            </div>
            <div class="setting-item">
                <label for="freq-min">Min Frequency (Hz)</label>
                <input type="number" id="freq-min" min="0.1" max="10" step="0.1" value="0.5">
                <div class="help-text">Minimum frequency for vibration filtering</div>
            </div>
            <div class="setting-item">
                <label for="freq-max">Max Frequency (Hz)</label>
                <input type="number" id="freq-max" min="10" max="100" step="1" value="50">
                <div class="help-text">Maximum frequency for vibration filtering</div>
            </div>
        </div>
        <div class="settings-buttons">
            <button id="settings-reset" onclick="resetSettings()">Reset to Defaults</button>
            <button id="settings-save" onclick="saveSettings()">Save Settings</button>
        </div>
    </div>
</div>

<section id="controls" style="margin-bottom:1rem;">
    <div id="button-bar">
        <button id="update-button" style="display:none;">Update Records</button>
    </div>
    <div id="loading" style="display:none; margin-top:1rem;">
        <progress id="load-progress" value="0" max="0" style="width:100%;"></progress>
        <span id="load-label"></span>
    </div>
</section>



<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
<script>
// Wait for document and resources to be ready before loading map
document.addEventListener('DOMContentLoaded', () => {
    // Ensure Leaflet is loaded
    if (typeof L === 'undefined') {
        console.error('Leaflet library not loaded');
        return;
    }
});
async function loadMapPartial() {
    try {
        const mapContainer = document.getElementById('map-container');
        if (!mapContainer) {
            console.error('Map container not found');
            return false;
        }

        const response = await fetch('map-partial.html');
        if (!response.ok) {
            throw new Error(`Failed to load map-partial.html: ${response.status} ${response.statusText}`);
        }

        const mapHtml = await response.text();
        
        // Parse the HTML to extract script content
        const parser = new DOMParser();
        const doc = parser.parseFromString(mapHtml, 'text/html');
        
        // Insert the HTML content (excluding scripts)
        const scripts = doc.querySelectorAll('script');
        const styles = doc.querySelectorAll('style');
        
        // Remove scripts and styles from the content to insert them separately
        scripts.forEach(script => script.remove());
        styles.forEach(style => style.remove());
        
        // Insert the HTML content
        mapContainer.innerHTML = doc.body.innerHTML;
        
        // Insert and execute styles
        styles.forEach(style => {
            const newStyle = document.createElement('style');
            newStyle.textContent = style.textContent;
            document.head.appendChild(newStyle);
        });
        
        // Insert and execute scripts
        for (const script of scripts) {
            const newScript = document.createElement('script');
            newScript.textContent = script.textContent;
            document.head.appendChild(newScript);
            
            // Wait a moment for script to execute
            await new Promise(resolve => setTimeout(resolve, 10));
        }
        
        return true;
    } catch (error) {
        console.error('Failed to load map partial:', error);
        if (typeof addDebug === 'function') {
            addDebug('Map partial loading error: ' + error.message, 'System', 'ERROR');
        }
        return false;
    }
}

async function loadLogsPartial() {
    try {
        const logsContainer = document.getElementById('logs-container');
        if (!logsContainer) {
            console.error('Logs container not found');
            return false;
        }

        const response = await fetch('logs-partial.html');
        if (!response.ok) {
            throw new Error(`Failed to load logs-partial.html: ${response.status} ${response.statusText}`);
        }

        const logsHtml = await response.text();
        
        // Parse the HTML to extract script content
        const parser = new DOMParser();
        const doc = parser.parseFromString(logsHtml, 'text/html');
        
        // Insert the HTML content (excluding scripts)
        const scripts = doc.querySelectorAll('script');
        const styles = doc.querySelectorAll('style');
        
        // Remove scripts and styles from the content to insert them separately
        scripts.forEach(script => script.remove());
        styles.forEach(style => style.remove());
        
        // Insert the HTML content
        logsContainer.innerHTML = doc.body.innerHTML;
        
        // Insert and execute styles
        styles.forEach(style => {
            const newStyle = document.createElement('style');
            newStyle.textContent = style.textContent;
            document.head.appendChild(newStyle);
        });
        
        // Insert and execute scripts
        for (const script of scripts) {
            const newScript = document.createElement('script');
            newScript.textContent = script.textContent;
            document.head.appendChild(newScript);
            
            // Wait a moment for script to execute
            await new Promise(resolve => setTimeout(resolve, 10));
        }
        
        return true;
    } catch (error) {
        console.error('Failed to load logs partial:', error);
        if (typeof addDebug === 'function') {
            addDebug('Logs partial loading error: ' + error.message, 'System', 'ERROR');
        }
        return false;
    }
}

// Authentication check - verify user is logged in
async function checkAuthentication() {
    try {
        const response = await fetch('/auth_check');
        if (!response.ok) {
            // Not authenticated, redirect to login
            window.location.href = '/static/login.html?next=' + encodeURIComponent(window.location.pathname);
            return false;
        }
        return true;
    } catch (error) {
        console.error('Authentication check failed:', error);
        // On error, assume not authenticated and redirect
        window.location.href = '/static/login.html?next=' + encodeURIComponent(window.location.pathname);
        return false;
    }
}

// Main page initialization
document.addEventListener('DOMContentLoaded', async () => {
    const isAuthenticated = await checkAuthentication();
    if (!isAuthenticated) {
        return; // Will be redirected
    }
    
    // Load map partial first
    const mapLoaded = await loadMapPartial();
    
    // Load logs partial
    const logsLoaded = await loadLogsPartial();
    
    if (mapLoaded) {
        // Wait for map functions to be available
        let attempts = 0;
        const maxAttempts = 50; // 5 seconds max
        
        while (typeof initializeStandardMap !== 'function' && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (typeof initializeStandardMap === 'function') {
            initializePage();
        } else {
            console.warn('Map functions not loaded, using fallback');
            createFallbackMap('map-container');
            initializePage();
        }
    } else {
        console.warn('Map partial failed to load, using fallback');
        createFallbackMap('map-container');
        initializePage();
    }
});

function initializePage() {
    // Move all the existing initialization code here
    updateStatus();
    initMap();
    
    // Only start pollDebug if debug element exists
    if (document.getElementById('debug')) {
        pollDebug();
    }
    
    // Initial status check
    checkDatabaseStatus();
    // Check database status periodically
    setInterval(checkDatabaseStatus, 30000);
    
    // Request wake lock by default when page loads
    requestWakeLock();
    
    // Load logs for current device only
    loadLogs();
}

let deviceId = localStorage.getItem('deviceId');
// Make deviceId available globally for logs partial
window.deviceId = deviceId;
function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 864e5).toUTCString();
    document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/`;
}
if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem('deviceId', deviceId);
    setCookie('deviceId', deviceId, 365);
}
// Update window.deviceId whenever deviceId changes
window.deviceId = deviceId;

// Initialize source data recording toggle from localStorage
let recordSourceData = localStorage.getItem('recordSourceData') !== null 
    ? localStorage.getItem('recordSourceData') === 'true' 
    : true; // Default to true when no setting exists
// Set the initial checkbox state
document.addEventListener('DOMContentLoaded', () => {
    const recordSourceDataElement = document.getElementById('record-source-data');
    if (recordSourceDataElement) {
        recordSourceDataElement.checked = recordSourceData;
    }

    // Set initial state of start/stop button
    updateToggleButton();
    
    // Load current threshold settings
    loadSettings();
    
    // Initialize toggle functionality
    const button = document.getElementById('toggle-explanation');
    const info = document.getElementById('roughness-info');
    const scale = document.getElementById('roughness-scale');
    
    if (button && info && scale) {
        button.addEventListener('click', () => {
            if (info.style.display === 'none' || !info.style.display) {
                info.style.display = 'block';
                scale.style.display = 'block';
                button.textContent = '‚ûñ Hide Roughness Explanation and Scale Reference';
            } else {
                info.style.display = 'none';
                scale.style.display = 'none';
                button.textContent = '‚ûï Show Roughness Explanation and Scale Reference';
            }
        });
    }
});
const userAgent = navigator.userAgent;
const fingerprint = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    navigator.platform,
    new Date().getTimezoneOffset()
].join('|');
const LOG_ENDPOINT = '/bike-data';

function loadNickname() {
    // Main page doesn't need nickname functionality
    currentNickname = '';
}

function saveNickname() {
    // Main page doesn't need nickname functionality
}

let xValues = [];
let yValues = [];
let zValues = [];
let lastLat = 0;
let lastLon = 0;
let lastSpeed = 0;
let lastDir = 0;
let lastRoughness = 0;
let lastAcc = {x:0, y:0, z:0};
let orientationData = {alpha:0, beta:0, gamma:0};
let roughMin = 0;
let roughMax = LABEL_COUNT;
let roughAvg = 0;
let roughScales = {};
let currentNickname = '';
let motionDataReceived = false;
let motionPermissionTimer = null;
let userLocation = null; // Store user's current location

// Status tracking variables
let locationStatus = false;
let accelerationStatus = false;
let databaseStatus = false;

function updateStatusIndicator(type, status) {
    const indicator = document.getElementById(`${type}-indicator`);
    
    if (indicator) {
        indicator.className = `status-indicator ${status ? 'status-green' : 'status-red'}`;
    }
    
    // Update the status display when indicators change
    updateStatus();
}

function checkDatabaseStatus() {
    fetch('/health')
        .then(response => {
            if (response.ok) {
                databaseStatus = true;
                updateStatusIndicator('database', true);
            } else {
                databaseStatus = false;
                updateStatusIndicator('database', false);
            }
        })
        .catch(err => {
            databaseStatus = false;
            updateStatusIndicator('database', false);
        });
}

if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
            orientationData = { alpha: event.alpha || 0, beta: event.beta, gamma: event.gamma };
        }
    });
}

function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(res => {
                addDebug('Motion permission: ' + res);
                if (res === 'granted') {
                    accelerationStatus = true;
                    updateStatusIndicator('acceleration', true);
                } else {
                    accelerationStatus = false;
                    updateStatusIndicator('acceleration', false);
                }
            })
            .catch(err => {
                addDebug('Motion permission error: ' + err);
                accelerationStatus = false;
                updateStatusIndicator('acceleration', false);
            });
    } else {
        // For browsers that don't require permission, check if motion events work
        if (typeof DeviceMotionEvent !== 'undefined') {
            updateStatusIndicator('acceleration', false);
        } else {
            accelerationStatus = false;
            updateStatusIndicator('acceleration', false);
        }
    }
}

function checkMotionPermission() {
    if (!motionDataReceived) {
        addDebug('No acceleration data received, requesting permission');
        requestMotionPermission();
        motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    } else {
        accelerationStatus = true;
        updateStatusIndicator('acceleration', true);
    }
}
const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
let geoWatchId = null;
let loggingEnabled = false;
let recordCount = 0;

function updateToggleButton() {
    const btn = document.getElementById('toggle');
    if (btn) {
        if (loggingEnabled) {
            btn.textContent = '‚èπÔ∏è Stop Recording';
            btn.className = 'recording';
        } else {
            btn.textContent = '‚ñ∂Ô∏è Start Recording';
            btn.className = 'stopped';
        }
    }
}

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        () => {
            addDebug('Geolocation permission granted');
            locationStatus = true;
            updateStatusIndicator('location', true);
        },
        err => {
            addDebug('Geolocation permission denied: ' + err.message);
            locationStatus = false;
            updateStatusIndicator('location', false);
        },
        GEO_OPTIONS
    );
} else {
    locationStatus = false;
    updateStatusIndicator('location', false);
}

function initMap() {
    const map = initializeStandardMap({
        center: [52.028, 5.168], // Houten, NL
        zoom: 16, // Street view zoom level for recording
        enableGeolocation: true,
        enableBicycleMarker: true,
        enableFullscreen: true,
        onLocationFound: (coords, position) => {
            locationStatus = true;
            updateStatusIndicator('location', true);
        },
        onLocationError: (error) => {
            locationStatus = false;
            updateStatusIndicator('location', false);
        }
    });
    
    // Initialize roughness filter
    initializeRoughnessFilter(() => {
        // Reload map data when filter changes
        loadLogs();
    });
}

function updateStatus() {
    const coordinatesEl = document.getElementById('coordinates-text');
    const speedEl = document.getElementById('speed-text');
    const roughnessEl = document.getElementById('roughness-text');
    const locationTextEl = document.getElementById('location-text');
    const motionTextEl = document.getElementById('motion-text');
    
    if (coordinatesEl) {
        coordinatesEl.textContent = `${lastLat.toFixed(5)}, ${lastLon.toFixed(5)}`;
    }
    if (speedEl) {
        speedEl.textContent = `${lastSpeed.toFixed(1)} km/h | ${lastDir.toFixed(0)}¬∞`;
    }
    if (roughnessEl) {
        roughnessEl.textContent = `R: ${lastRoughness.toFixed(2)}`;
    }
    if (locationTextEl) {
        locationTextEl.textContent = locationStatus ? 'GPS Active' : 'GPS Searching';
    }
    if (motionTextEl) {
        motionTextEl.textContent = accelerationStatus ? 'Motion Active' : 'Motion Waiting';
    }
}

function zUp(acc) {
    const beta = orientationData.beta * Math.PI / 180;
    const gamma = orientationData.gamma * Math.PI / 180;
    const gX = -Math.sin(beta);
    const gY = Math.cos(beta) * Math.sin(gamma);
    const gZ = Math.cos(beta) * Math.cos(gamma);
    const upX = -gX;
    const upY = -gY;
    const upZ = -gZ;
    const mag = Math.sqrt(upX*upX + upY*upY + upZ*upZ) || 1;
    return (acc.x * upX + acc.y * upY + acc.z * upZ) / mag;
}

function loadLogs() {
    // Load logs for current device only
    let url = '/filteredlogs';
    if (deviceId) {
        const params = new URLSearchParams();
        params.append('device_id', deviceId);
        url = '/filteredlogs?' + params.toString();
    } else {
        // Fallback to all logs if no device ID
        url = '/logs';
    }
    fetch(url).then(r => r.json()).then(async data => {
        const rows = Array.isArray(data) ? data : data.rows;
        roughAvg = data.average || 0;
        const loadBox = document.getElementById('loading');
        const prog = document.getElementById('load-progress');
        const label = document.getElementById('load-label');
        
        if (prog && label) {
            prog.max = rows.length;
            prog.value = 0;
            label.textContent = `0 / ${rows.length}`;
        }
        
        if (loadBox) {
            loadBox.style.display = 'block';
        }
        
        // Clear existing map data
        clearMapData();
        
        roughMin = 0;
        roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
        roughScales = {};
        rows.forEach(row => {
            if (!row || typeof row.roughness !== 'number' || !row.device_id) return;
            const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
            s.min = Math.min(s.min, row.roughness);
            s.max = Math.max(s.max, row.roughness);
            roughScales[row.device_id] = s;
        });
        updateRoughnessLabels();
        for (let i = rows.length - 1; i >= 0; i--) {
            const row = rows[i];
            if (!row || typeof row.roughness !== 'number' || typeof row.latitude !== 'number' || typeof row.longitude !== 'number') continue;
            if (!filterRoughness(row.roughness)) continue;
            const scale = roughScales[row.device_id] || {min:0,max:1};
            addPoint(row.latitude, row.longitude, row.roughness, row, '', scale.min, scale.max);
            if (prog && label) {
                prog.value = rows.length - i;
                label.textContent = `${rows.length - i} / ${rows.length}`;
            }
            if ((rows.length - i) % 100 === 0) await new Promise(r => setTimeout(r, 0));
        }
        if (loadBox) {
            loadBox.style.display = 'none';
        }
        addLog(`Total records loaded: ${rows.length}`);
        recordCount = rows.length;
    }).catch(err => console.error(err));
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', (event) => {
        if (event.accelerationIncludingGravity) {
            const acc = event.accelerationIncludingGravity;
            if (!motionDataReceived) {
                motionDataReceived = true;
                accelerationStatus = true;
                updateStatusIndicator('acceleration', true);
            }
            xValues.push(acc.x || 0);
            yValues.push(acc.y || 0);
            const zUpVal = zUp(acc);
            zValues.push(zUpVal);
            lastAcc = { x: acc.x || 0, y: acc.y || 0, z: zUpVal };
            updateStatus();
        }
    });
} else {
    accelerationStatus = false;
    updateStatusIndicator('acceleration', false);
}

function handlePosition(pos) {
    const { latitude, longitude, speed, heading } = pos.coords;
    lastLat = latitude;
    lastLon = longitude;
    lastSpeed = (speed || 0) * 3.6; // convert to km/h
    lastDir = heading || 0;
    
    // Update status indicator when GPS data is received
    locationStatus = true;
    updateStatusIndicator('location', true);

    // Update user location
    userLocation = [latitude, longitude];
    
    // Update bicycle marker if it exists
    if (window.bicycleMarker) {
        updateBicycleMarker([latitude, longitude], {
            speed: lastSpeed,
            direction: lastDir
        });
    }
    
    updateStatus();
    //addLog(`Location: ${latitude}, ${longitude} speed: ${lastSpeed.toFixed(1)} km/h`);
    if (loggingEnabled && zValues.length > 0) {
        const requestBody = {
            latitude,
            longitude,
            speed: lastSpeed,
            direction: lastDir,
            z_values: zValues,
            device_id: deviceId,
            user_agent: userAgent,
            device_fp: fingerprint,
            record_source_data: recordSourceData
        };
        
        fetch(LOG_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        }).then(r => r.json()).then(data => {
            if (data.roughness !== undefined) {
                lastRoughness = data.roughness;
                addLog(`Record inserted, roughness: ${data.roughness.toFixed(2)}`);
                updateStatus();
                const scale = roughScales[deviceId] || {min: data.roughness, max: data.roughness};
                if (filterRoughness(data.roughness)) {
                    addPoint(latitude, longitude, data.roughness, {
                        timestamp: new Date().toLocaleString('sv-SE', { timeZone: 'Europe/Amsterdam' }),
                        speed: lastSpeed,
                        direction: lastDir,
                        roughness: data.roughness
                    }, currentNickname, scale.min, scale.max);
                }
                scale.min = Math.min(scale.min, data.roughness);
                scale.max = Math.max(scale.max, data.roughness);
                roughScales[deviceId] = scale;
                recordCount += 1;
                
                // Do not reload all logs during active recording
            }
        }).catch(err => addDebug('Error: ' + err));
        xValues = [];
        yValues = [];
        zValues = [];
    }
}

function handleGeoError(err) {
    addDebug('Geolocation error: ' + err.message);
    locationStatus = false;
    updateStatusIndicator('location', false);
}

async function startGeolocation() {
    if (!navigator.geolocation) {
        addDebug('Geolocation not supported');
        locationStatus = false;
        updateStatusIndicator('location', false);
        return;
    }
    motionDataReceived = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
    }
    requestMotionPermission();
    motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    if (geoWatchId === null) {
        geoWatchId = navigator.geolocation.watchPosition(
            handlePosition,
            handleGeoError,
            GEO_OPTIONS
        );
    }
    loggingEnabled = true;
    updateToggleButton();

    // Wake lock is already active by default, no need to request again
}

async function stopGeolocation() {
    loggingEnabled = false;
    updateToggleButton();
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
        motionPermissionTimer = null;
    }
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
    }
    
    // Wake lock stays active by default, no need to release it when stopping recording
}

function pollDebug() {
    fetch('/debuglog').then(r => r.json()).then(data => {
        const debugElement = document.getElementById('debug');
        if (debugElement) {
            debugElement.value = data.log.join('\n');
        }
    }).catch(console.error).finally(() => setTimeout(pollDebug, 10000));
}



document.getElementById('toggle').addEventListener('click', async () => {
    if (loggingEnabled) {
        await stopGeolocation();
        addLog('Logging stopped');
    } else {
        await startGeolocation();
        addLog('Logging started');
    }
    updateToggleButton();
});

const updateBtn = document.getElementById('update-button');
if (updateBtn) {
    updateBtn.addEventListener('click', () => {
        addLog('Update Records pressed');
        loadLogs();
    });
}

// Only add nickname event listener if the elements exist
const saveNicknameBtn = document.getElementById('save-nickname');
if (saveNicknameBtn) {
    saveNicknameBtn.addEventListener('click', () => {
        addLog('Save Nickname pressed');
        saveNickname();
    });
}

// Add event listeners after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const roughnessFilter = document.getElementById('roughness-filter');
    if (roughnessFilter) {
        roughnessFilter.addEventListener('change', () => {
            if (typeof loadLogs === 'function') {
                loadLogs();
            }
        });
    }

    const recordSourceDataElement = document.getElementById('record-source-data');
    if (recordSourceDataElement) {
        recordSourceDataElement.addEventListener('change', (e) => {
            recordSourceData = e.target.checked;
            addLog(`Source data recording ${recordSourceData ? 'enabled' : 'disabled'}`);
            localStorage.setItem('recordSourceData', recordSourceData.toString());
        });
    }
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});



let wakeLock = null;
let wakeLockSupported = false;

function updateWakeLockStatus() {
    const statusElement = document.getElementById('wake-lock-status');
    const manualButton = document.getElementById('manual-wake-lock');
    const indicator = document.getElementById('wakelock-indicator');
    
    if (!('wakeLock' in navigator)) {
        if (statusElement) {
            statusElement.innerHTML = '‚ùå Wake Lock not supported in this browser';
            statusElement.style.color = 'red';
        }
        if (manualButton) manualButton.disabled = true;
        if (indicator) {
            indicator.className = 'status-indicator status-red';
        }
        return;
    }
    
    const isActive = wakeLock !== null && !wakeLock.released;
    
    if (isActive) {
        if (statusElement) {
            statusElement.innerHTML = 'üîÜ Screen locked on - won\'t turn off during recording';
            statusElement.style.color = 'green';
        }
        if (indicator) {
            indicator.className = 'status-indicator status-green';
        }
    } else {
        if (statusElement) {
            statusElement.innerHTML = 'üí§ Screen may turn off - tap "Toggle Wake Lock" to prevent';
            statusElement.style.color = 'orange';
        }
        if (indicator) {
            indicator.className = 'status-indicator status-red';
        }
    }
    
    if (manualButton) {
        manualButton.textContent = isActive ? 'Release Wake Lock' : 'Request Wake Lock';
        manualButton.disabled = false;
    }
}

async function requestWakeLock() {
    if (!('wakeLock' in navigator)) {
        addDebug('Wake Lock API not supported in this browser');
        updateWakeLockStatus();
        return false;
    }
    
    try {
        // Check if we already have an active wake lock
        if (wakeLock !== null && !wakeLock.released) {
            addDebug('Wake lock already active');
            return true;
        }
        
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLockSupported = true;
        
        wakeLock.addEventListener('release', async () => {
            addDebug('Wake lock released (may have been due to tab switch or battery saving)');
            updateWakeLockStatus();
            if (loggingEnabled) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    addDebug('Wake lock re-acquired automatically');
                    updateWakeLockStatus();
                } catch (err) {
                    addDebug('Failed to re-acquire wake lock: ' + err.message);
                }
            }
        });
        
        addDebug('Wake lock acquired - screen will stay on during recording');
        updateWakeLockStatus();
        return true;
    } catch (err) {
        if (err.name === 'NotAllowedError') {
            addDebug('Wake lock denied - user may need to grant permission');
        } else if (err.name === 'NotSupportedError') {
            addDebug('Wake lock not supported on this device');
        } else {
            addDebug('Wake lock error: ' + err.message);
        }
        updateWakeLockStatus();
        return false;
    }
}

async function releaseWakeLock() {
    if (wakeLock !== null) {
        try {
            await wakeLock.release();
            wakeLock = null;
            addDebug('Wake lock manually released - screen may turn off');
        } catch (err) {
            addDebug('Wake lock release error: ' + err.message);
        }
        updateWakeLockStatus();
    }
}

// Manual wake lock toggle
async function toggleWakeLock() {
    if (wakeLock !== null && !wakeLock.released) {
        await releaseWakeLock();
    } else {
        await requestWakeLock();
    }
}

// Initialize wake lock status display
updateWakeLockStatus();

// Add manual wake lock button event listener after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const manualWakeLockBtn = document.getElementById('manual-wake-lock');
    if (manualWakeLockBtn) {
        manualWakeLockBtn.addEventListener('click', toggleWakeLock);
    }
});

// Re-request wake lock when page becomes visible again (only if recording)
if ('wakeLock' in navigator) {
    document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'visible' && loggingEnabled) {
            // Small delay to ensure the page is fully visible
            setTimeout(async () => {
                if (wakeLock === null || wakeLock.released) {
                    addDebug('Page became visible during recording - requesting wake lock');
                    await requestWakeLock();
                }
            }, 100);
        }
    });
    
    // Also handle page focus events for additional reliability
    window.addEventListener('focus', async () => {
        if (loggingEnabled && (wakeLock === null || wakeLock.released)) {
            addDebug('Window focused during recording - requesting wake lock');
            await requestWakeLock();
        }
    });
}

// Note: toggleSettings() is now available from utils.js

function loadSettings() {
    fetch('/api/thresholds')
        .then(r => r.json())
        .then(data => {
            document.getElementById('max-interval').value = data.max_interval_sec;
            document.getElementById('max-distance').value = data.max_distance_m;
            document.getElementById('min-speed').value = data.min_speed_kmh;
            document.getElementById('freq-min').value = data.freq_min;
            document.getElementById('freq-max').value = data.freq_max;
        })
        .catch(err => {
            console.error('Failed to load settings:', err);
            addLog('Failed to load threshold settings');
        });
}

function saveSettings() {
    const settings = {
        max_interval_sec: parseFloat(document.getElementById('max-interval').value),
        max_distance_m: parseFloat(document.getElementById('max-distance').value),
        min_speed_kmh: parseFloat(document.getElementById('min-speed').value),
        freq_min: parseFloat(document.getElementById('freq-min').value),
        freq_max: parseFloat(document.getElementById('freq-max').value)
    };
    
    // Validate frequency range
    if (settings.freq_min >= settings.freq_max) {
        alert('Minimum frequency must be less than maximum frequency');
        return;
    }
    
    fetch('/api/thresholds', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
    })
    .then(r => {
        if (!r.ok) {
            return r.json().then(err => Promise.reject(err));
        }
        return r.json();
    })
    .then(data => {
        addLog('‚úÖ Threshold settings saved successfully');
        console.log('Settings saved:', data.thresholds);
    })
    .catch(err => {
        console.error('Failed to save settings:', err);
        addLog('‚ùå Failed to save threshold settings: ' + (err.detail || err.message || 'Unknown error'));
    });
}

function resetSettings() {
    if (confirm('Reset all threshold settings to default values?')) {
        // Default values from the backend
        document.getElementById('max-interval').value = 15;
        document.getElementById('max-distance').value = 100;
        document.getElementById('min-speed').value = 0;
        document.getElementById('freq-min').value = 0.5;
        document.getElementById('freq-max').value = 50;
        
        // Save the defaults
        saveSettings();
    }
}

</script>

<!-- Include Activity Log and Debug Messages Partial -->
<div id="logs-container"></div>

</body>
</html>
