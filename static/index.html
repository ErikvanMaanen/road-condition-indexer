<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Condition Indexer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
        #map { width: 100%; height: 40vh; margin-bottom: 1rem; }
        #map:fullscreen { width: 100%; height: 100%; }
        #status { margin-bottom: 1rem; font-weight: bold; }
        #button-bar { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input:disabled { opacity: 0.5; cursor: not-allowed; }
        #toggle { padding: 1rem 2rem; font-size: 1.25rem; }
        #scale-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }
        #scale-bar {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, green, yellow, red);
            border: 1px solid #ccc;
        }
        #status-indicators {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 0.8rem;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .status-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            gap: 6px;
        }
        .status-item:last-child {
            margin-bottom: 0;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
        }
        .status-green {
            background-color: #4CAF50;
        }
        .status-red {
            background-color: #f44336;
        }
        .status-explanation {
            font-size: 0.7rem;
            color: #666;
            margin-left: 16px;
        }
        #wake-lock-container {
            transition: background-color 0.3s ease;
        }
        #wake-lock-container:hover {
            background: #f0f0f0;
        }
        #manual-wake-lock:hover {
            background: #e0e0e0;
        }
        /* Settings panel styles */
        #settings-panel {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 1rem 0;
            background: #f9f9f9;
        }
        #settings-header {
            padding: 8px 12px;
            background: #e9e9e9;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #settings-header:hover {
            background: #ddd;
        }
        #settings-content {
            padding: 12px;
            display: none;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .setting-item label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
        }
        .setting-item input {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        .setting-item .help-text {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
        }
        .settings-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            border-top: 1px solid #ddd;
            padding-top: 8px;
            margin-top: 8px;
        }
        .settings-buttons button {
            padding: 6px 12px;
            font-size: 0.85rem;
            border-radius: 3px;
        }
        #settings-save {
            background: #4CAF50;
            color: white;
            border: 1px solid #45a049;
        }
        #settings-save:hover {
            background: #45a049;
        }
        #settings-reset {
            background: #f44336;
            color: white;
            border: 1px solid #d32f2f;
        }
        #settings-reset:hover {
            background: #d32f2f;
        }
    </style>
</head>
<body>
<h1>Road Condition Indexer</h1>
<!-- Status indicators in top right -->
<div id="status-indicators">
    <div class="status-item">
        <div id="location-indicator" class="status-indicator status-red"></div>
        <span>Location</span>
        <div id="location-explanation" class="status-explanation">Checking GPS access...</div>
    </div>
    <div class="status-item">
        <div id="acceleration-indicator" class="status-indicator status-red"></div>
        <span>Motion</span>
        <div id="acceleration-explanation" class="status-explanation">Checking accelerometer...</div>
    </div>
    <div class="status-item">
        <div id="database-indicator" class="status-indicator status-red"></div>
        <span>Database</span>
        <div id="database-explanation" class="status-explanation">Checking DB connection...</div>
    </div>
    <div class="status-item">
        <div id="wakelock-indicator" class="status-indicator status-red"></div>
        <span>Wake Lock</span>
        <div id="wakelock-explanation" class="status-explanation">Screen may turn off</div>
    </div>
</div>
<nav id="page-links" style="margin-bottom:1rem;">
    <a href="device.html">Device View</a>
</nav>
<!-- Hidden maintenance link as a square at bottom right -->
<a href="maintenance.html" id="maintenance-link" style="position:fixed;bottom:24px;right:24px;width:32px;height:32px;display:block;z-index:9999;opacity:0.2;background:#888;border-radius:6px;text-align:center;line-height:32px;text-decoration:none;font-size:1.5rem;transition:opacity 0.2s;" title="Maintenance">üõ†Ô∏è</a>
<script>
// Show the maintenance link on hover or focus
const maintLink = document.getElementById('maintenance-link');
maintLink.addEventListener('mouseenter',()=>maintLink.style.opacity='1');
maintLink.addEventListener('mouseleave',()=>maintLink.style.opacity='0.2');
maintLink.addEventListener('focus',()=>maintLink.style.opacity='1');
maintLink.addEventListener('blur',()=>maintLink.style.opacity='0.2');
</script>
<section id="filter-dev" style="margin-bottom:1rem;">
    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
        <select id="roughness-filter" multiple style="min-width:180px;">
            <option value="">[All Roughness]</option>
            <option value="1">1 - Smooth road</option>
            <option value="2">2 - Even surface</option>
            <option value="3">3 - Light texture</option>
            <option value="4">4 - Coarse texture</option>
            <option value="5">5 - Moderate roughness</option>
            <option value="6">6 - Bumpy cobbles</option>
            <option value="7">7 - Fine gravel</option>
            <option value="8">8 - Coarse gravel</option>
            <option value="9">9 - Severely uneven</option>
            <option value="10">10 - Extremely rough</option>
        </select>
        <select id="device-filter" multiple></select>
    </div>
</section>
<div id="map"></div>
<div id="scale-container">
    <span>Smooth</span>
    <div id="scale-bar"></div>
    <span>Rough</span>
</div>
<div style="margin-bottom:1rem;">
    <label>
        <input type="checkbox" id="center-on-user" checked> Keep map centered on my location
    </label>
    <br>
    <label>
        <input type="checkbox" id="record-source-data"> Record source data for retrospective analysis
    </label>
    <div style="font-size: 0.8rem; color: #666; margin-top: 4px; margin-left: 20px;">
        When enabled, stores raw acceleration data for recalculating roughness values later
    </div>
</div>

<!-- Settings Panel -->
<div id="settings-panel">
    <div id="settings-header" onclick="toggleSettings()">
        <span>‚öôÔ∏è Recording Thresholds</span>
        <span id="settings-toggle">‚ñº</span>
    </div>
    <div id="settings-content">
        <div class="settings-grid">
            <div class="setting-item">
                <label for="max-interval">Max Time Interval (sec)</label>
                <input type="number" id="max-interval" min="1" max="300" step="1" value="15">
                <div class="help-text">Maximum time between data points before ignoring</div>
            </div>
            <div class="setting-item">
                <label for="max-distance">Max Distance (m)</label>
                <input type="number" id="max-distance" min="10" max="10000" step="10" value="100">
                <div class="help-text">Maximum distance between points before ignoring</div>
            </div>
            <div class="setting-item">
                <label for="min-speed">Min Speed (km/h)</label>
                <input type="number" id="min-speed" min="0" max="200" step="0.1" value="0">
                <div class="help-text">Minimum speed for recording data (0 = no limit)</div>
            </div>
            <div class="setting-item">
                <label for="freq-min">Min Frequency (Hz)</label>
                <input type="number" id="freq-min" min="0.1" max="10" step="0.1" value="0.5">
                <div class="help-text">Minimum frequency for vibration filtering</div>
            </div>
            <div class="setting-item">
                <label for="freq-max">Max Frequency (Hz)</label>
                <input type="number" id="freq-max" min="10" max="100" step="1" value="50">
                <div class="help-text">Maximum frequency for vibration filtering</div>
            </div>
        </div>
        <div class="settings-buttons">
            <button id="settings-reset" onclick="resetSettings()">Reset to Defaults</button>
            <button id="settings-save" onclick="saveSettings()">Save Settings</button>
        </div>
    </div>
</div>

<section id="controls" style="margin-bottom:1rem;">
    <div id="status"></div>
    <div id="wake-lock-container" style="border: 1px solid #ddd; border-radius: 4px; padding: 8px; margin: 0.5rem 0; background: #f9f9f9;">
        <div id="wake-lock-status" style="font-size: 0.9rem; font-weight: bold;">üí§ Screen may turn off</div>
        <div style="font-size: 0.8rem; color: #666; margin-top: 4px;">
            Wake lock prevents screen from turning off during recording
        </div>
        <button id="manual-wake-lock" style="margin-top: 4px; padding: 4px 8px; font-size: 0.8rem; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
            Toggle Wake Lock
        </button>
    </div>
    <div id="button-bar">
        <button id="toggle">Start</button>
        <button id="update-button" style="margin-left:1rem; display:none;">Update Records</button>
    </div>
    <div id="loading" style="display:none; margin-top:1rem;">
        <progress id="load-progress" value="0" max="0" style="width:100%;"></progress>
        <span id="load-label"></span>
    </div>
</section>



<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let deviceId = localStorage.getItem('deviceId');
let selectedIds = deviceId ? [deviceId] : [];
function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 864e5).toUTCString();
    document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/`;
}
if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem('deviceId', deviceId);
    setCookie('deviceId', deviceId, 365);
}

// Initialize source data recording toggle from localStorage
let recordSourceData = localStorage.getItem('recordSourceData') === 'true';
// Set the initial checkbox state
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('record-source-data').checked = recordSourceData;

    // Set initial state of start/stop button
    updateToggleButton();
    
    // Load logs partial
    loadLogsPartial();
    
    // Load current threshold settings
    loadSettings();
    
    // Initialize toggle functionality
    const button = document.getElementById('toggle-explanation');
    const info = document.getElementById('roughness-info');
    const scale = document.getElementById('roughness-scale');
    
    if (button && info && scale) {
        button.addEventListener('click', () => {
            if (info.style.display === 'none' || !info.style.display) {
                info.style.display = 'block';
                scale.style.display = 'block';
                button.textContent = '‚ûñ Hide Roughness Explanation and Scale Reference';
            } else {
                info.style.display = 'none';
                scale.style.display = 'none';
                button.textContent = '‚ûï Show Roughness Explanation and Scale Reference';
            }
        });
    }
});
const userAgent = navigator.userAgent;
const fingerprint = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    navigator.platform,
    new Date().getTimezoneOffset()
].join('|');
const LOG_ENDPOINT = '/log';

function loadNickname() {
    const nickInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('save-nickname');
    
    // Main page doesn't have nickname controls, so just return silently
    if (!nickInput || !saveBtn) {
        currentNickname = '';
        return;
    }
    
    if (selectedIds.length !== 1) {
        nickInput.value = '';
        nickInput.placeholder = selectedIds.length === 0 ? 'Device nickname' : 'Select single device to edit nickname';
        nickInput.disabled = true;
        saveBtn.disabled = true;
        currentNickname = '';
        return;
    }
    nickInput.disabled = false;
    saveBtn.disabled = false;
    nickInput.placeholder = 'Device nickname';
    const id = selectedIds[0];
    fetch(`/nickname?device_id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(data => {
            currentNickname = data.nickname || '';
            nickInput.value = currentNickname;
        })
        .catch(console.error);
}

function saveNickname() {
    const nickInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('save-nickname');
    if (!nickInput || !saveBtn || selectedIds.length !== 1 || nickInput.disabled || saveBtn.disabled) return;
    const name = nickInput.value;
    const deviceId = selectedIds[0];
    fetch('/nickname', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_id: deviceId, nickname: name })
    }).then(() => {
        // Update local nickname without reloading all devices
        deviceNicknames[deviceId] = name;
        currentNickname = name;
        
        // Update the device option in the select dropdown
        const select = document.getElementById('device-filter');
        for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === deviceId) {
                select.options[i].textContent = name ? `${name} (${deviceId})` : deviceId;
                break;
            }
        }
        addLog(`Saved nickname: ${name}`);
    }).catch(err => {
        addLog('Failed to save nickname: ' + err);
        console.error(err);
    });
}

function populateDeviceFilter() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const select = document.getElementById('device-filter');
        select.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        select.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            select.appendChild(opt);
        });
        if (deviceId && !data.ids.some(i => i.id === deviceId)) {
            const opt = document.createElement('option');
            opt.value = deviceId;
            opt.textContent = deviceId;
            select.appendChild(opt);
        }
        Array.from(select.options).forEach(o => {
            if (selectedIds.includes(o.value)) o.selected = true;
        });
        selectedIds = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
        // Update database status indicator
        databaseStatus = true;
        updateStatusIndicator('database', true);
    }).then(() => { loadNickname(); loadLogs(); })
      .catch(err => {
          console.error(err);
          databaseStatus = false;
          updateStatusIndicator('database', false, 'Failed to load device list');
      });
}
let xValues = [];
let yValues = [];
let zValues = [];
let lastLat = 0;
let lastLon = 0;
let lastSpeed = 0;
let lastDir = 0;
let lastRoughness = 0;
let lastAcc = {x:0, y:0, z:0};
let map;
let orientationData = {alpha:0, beta:0, gamma:0};
let roughMin = 0;
const LABEL_COUNT = 10;
const ROUGHNESS_NAMES = [
    'Smooth road',
    'Even surface',
    'Light texture',
    'Coarse texture',
    'Moderate roughness',
    'Bumpy cobbles',
    'Fine gravel',
    'Coarse gravel',
    'Severely uneven',
    'Extremely rough'
];
let roughMax = LABEL_COUNT;
let roughAvg = 0;
let roughScales = {};
let deviceNicknames = {};
let currentNickname = '';
let motionDataReceived = false;
let motionPermissionTimer = null;
let userLocation = null; // Store user's current location

// Status tracking variables
let locationStatus = false;
let accelerationStatus = false;
let databaseStatus = false;

function updateStatusIndicator(type, status, explanation = '') {
    const indicator = document.getElementById(`${type}-indicator`);
    const explanationEl = document.getElementById(`${type}-explanation`);
    
    if (indicator) {
        indicator.className = `status-indicator ${status ? 'status-green' : 'status-red'}`;
    }
    
    if (explanationEl) {
        explanationEl.textContent = explanation;
        explanationEl.style.display = explanation ? 'block' : 'none';
    }
}

function checkDatabaseStatus() {
    fetch('/device_ids')
        .then(response => {
            if (response.ok) {
                databaseStatus = true;
                updateStatusIndicator('database', true);
            } else {
                databaseStatus = false;
                updateStatusIndicator('database', false, 'Database connection failed');
            }
        })
        .catch(err => {
            databaseStatus = false;
            updateStatusIndicator('database', false, 'Database unreachable');
        });
}

// Load logs partial with improved error handling
async function loadLogsPartial() {
    try {
        const response = await fetch('logs-partial.html');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.text();
        const container = document.getElementById('logs-container');
        if (container) {
            container.innerHTML = data;
            // Execute any scripts in the loaded content
            const scripts = container.querySelectorAll('script');
            scripts.forEach(script => {
                const newScript = document.createElement('script');
                newScript.textContent = script.textContent;
                document.head.appendChild(newScript);
            });
        }
    } catch (error) {
        console.error('Error loading logs partial:', error);
        // Fallback: create basic log functions if partial fails to load
        window.addLog = function(msg) {
            console.log('Log:', msg);
        };
        window.addDebug = function(msg, category = 'Debug', level = 'DEBUG') {
            console.log(`Debug [${level}] [${category}]:`, msg);
        };
        window.addMessage = function(msg, level = 'INFO', category = 'General') {
            console.log(`Message [${level}] [${category}]:`, msg);
        };
        window.toggleLogs = function() {
            console.log('Logs toggle requested but partial not loaded');
        };
    }
}



if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
            orientationData = { alpha: event.alpha || 0, beta: event.beta, gamma: event.gamma };
        }
    });
}

function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(res => {
                addDebug('Motion permission: ' + res);
                if (res === 'granted') {
                    accelerationStatus = true;
                    updateStatusIndicator('acceleration', true);
                } else {
                    accelerationStatus = false;
                    updateStatusIndicator('acceleration', false, 'Motion permission denied');
                }
            })
            .catch(err => {
                addDebug('Motion permission error: ' + err);
                accelerationStatus = false;
                updateStatusIndicator('acceleration', false, 'Motion permission error');
            });
    } else {
        // For browsers that don't require permission, check if motion events work
        if (typeof DeviceMotionEvent !== 'undefined') {
            updateStatusIndicator('acceleration', false, 'Waiting for motion data...');
        } else {
            accelerationStatus = false;
            updateStatusIndicator('acceleration', false, 'Motion sensors not supported');
        }
    }
}

function checkMotionPermission() {
    if (!motionDataReceived) {
        addDebug('No acceleration data received, requesting permission');
        requestMotionPermission();
        motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    } else {
        accelerationStatus = true;
        updateStatusIndicator('acceleration', true);
    }
}
const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
let geoWatchId = null;
let loggingEnabled = false;
let recordCount = 0;

function updateToggleButton() {
    const btn = document.getElementById('toggle');
    if (btn) {
        btn.textContent = loggingEnabled ? 'Stop' : 'Start';
    }
}

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        () => {
            addDebug('Geolocation permission granted');
            locationStatus = true;
            updateStatusIndicator('location', true);
        },
        err => {
            addDebug('Geolocation permission denied: ' + err.message);
            locationStatus = false;
            updateStatusIndicator('location', false, 'GPS permission denied or unavailable');
        },
        GEO_OPTIONS
    );
} else {
    locationStatus = false;
    updateStatusIndicator('location', false, 'Geolocation not supported by browser');
}

function initMap() {
    const defaultPos = [52.028, 5.168]; // Houten, NL
    const zoom = 16; // Street view zoom level
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    
    const setView = coords => {
        userLocation = coords;
        map.setView(coords, zoom);
    };
    
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => {
                const coords = [pos.coords.latitude, pos.coords.longitude];
                setView(coords);
                addLog('Map centered on your location');
                locationStatus = true;
                updateStatusIndicator('location', true);
            },
            () => {
                setView(defaultPos);
                addLog('Using default location (Houten, NL)');
                locationStatus = false;
                updateStatusIndicator('location', false, 'GPS unavailable, using default location');
            },
            GEO_OPTIONS
        );
    } else {
        setView(defaultPos);
        addLog('Geolocation not supported, using default location');
        locationStatus = false;
        updateStatusIndicator('location', false, 'Geolocation not supported by browser');
    }
    addFullscreenControl(map);
}

function addFullscreenControl(m) {
    const Full = L.Control.extend({
        onAdd: function() {
            const btn = L.DomUtil.create('button', 'leaflet-bar');
            btn.textContent = '‚§¢';
            L.DomEvent.on(btn, 'click', () => {
                const el = m.getContainer();
                addLog('Fullscreen button pressed');
                if (!document.fullscreenElement) {
                    el.requestFullscreen?.();
                } else {
                    document.exitFullscreen?.();
                }
            });
            return btn;
        }
    });
    m.addControl(new Full({ position: 'topleft' }));
}

function updateStatus() {
    const el = document.getElementById('status');
    el.textContent =
        `Lat: ${lastLat.toFixed(5)}, Lon: ${lastLon.toFixed(5)} | ` +
        `Speed: ${lastSpeed.toFixed(1)} km/h | ` +
        `Dir: ${lastDir.toFixed(0)}\u00B0 | ` +
        `Acc: X: ${lastAcc.x.toFixed(2)} ` +
        `Y: ${lastAcc.y.toFixed(2)} ` +
        `Z: ${lastAcc.z.toFixed(2)} | ` +
        `Roughness: ${lastRoughness.toFixed(2)}`;
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const ratio = (Math.log(r + offset) - logMin) / (logMax - logMin);
    const idx = Math.max(0, Math.min(LABEL_COUNT - 1, Math.floor(ratio * LABEL_COUNT)));
    return String(idx + 1);
}

function roughnessRange(idx) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const low = Math.exp((logMax - logMin) * idx / LABEL_COUNT + logMin) - offset;
    const high = Math.exp((logMax - logMin) * (idx + 1) / LABEL_COUNT + logMin) - offset;
    return [low, high];
}

function updateRoughnessLabels() {
    const select = document.getElementById('roughness-filter');
    if (select) {
        for (let i = 0; i < LABEL_COUNT; i++) {
            const opt = select.options[i + 1];
            if (!opt) continue;
            const [low, high] = roughnessRange(i);
            opt.textContent = `${i + 1} - ${ROUGHNESS_NAMES[i]} (${low.toFixed(2)}-${high.toFixed(2)})`;
        }
    }
    const items = document.querySelectorAll('#roughness-scale ol li');
    items.forEach((li, idx) => {
        if (idx >= LABEL_COUNT) return;
        const [low, high] = roughnessRange(idx);
        li.textContent = `${ROUGHNESS_NAMES[idx]} (${low.toFixed(2)}-${high.toFixed(2)})`;
    });
}

// Utility function to format time in Dutch timezone
function formatDutchTime(isoString) {
    try {
        const date = new Date(isoString);
        return date.toLocaleString('nl-NL', {
            timeZone: 'Europe/Amsterdam',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    } catch (error) {
        return isoString; // Fallback to original string
    }
}

// Utility function to convert timestamp to CEST datetime-local format
function toCESTDateTimeLocal(timestamp) {
    try {
        const date = new Date(timestamp);
        // Convert to Europe/Amsterdam timezone
        const cesTime = new Date(date.toLocaleString('sv-SE', { timeZone: 'Europe/Amsterdam' }));
        return cesTime.toISOString().slice(0, 16);
    } catch (error) {
        // Fallback to UTC
        return new Date(timestamp).toISOString().slice(0, 16);
    }
}

function filterRoughness(r) {
    const sel = document.getElementById('roughness-filter');
    if (!sel) return true;
    const values = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (values.length === 0) return true;
    return values.includes(roughnessLabel(r));
}

function zUp(acc) {
    const beta = orientationData.beta * Math.PI / 180;
    const gamma = orientationData.gamma * Math.PI / 180;
    const gX = -Math.sin(beta);
    const gY = Math.cos(beta) * Math.sin(gamma);
    const gZ = Math.cos(beta) * Math.cos(gamma);
    const upX = -gX;
    const upY = -gY;
    const upZ = -gZ;
    const mag = Math.sqrt(upX*upX + upY*upY + upZ*upZ) || 1;
    return (acc.x * upX + acc.y * upY + acc.z * upZ) / mag;
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = formatDutchTime(info.timestamp);
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
    if (info && info.id) {
        marker.on('click', () => {
            localStorage.setItem('selectedRecordId', info.id);
        });
    }
}

function loadLogs() {
    const select = document.getElementById('device-filter');
    const ids = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
    let url = '/logs';
    if (ids.length > 0) {
        const params = new URLSearchParams();
        ids.forEach(id => params.append('device_id', id));
        url = '/filteredlogs?' + params.toString();
    }
    fetch(url).then(r => r.json()).then(async data => {
        const rows = Array.isArray(data) ? data : data.rows;
        roughAvg = data.average || 0;
        const loadBox = document.getElementById('loading');
        const prog = document.getElementById('load-progress');
        const label = document.getElementById('load-label');
        prog.max = rows.length;
        prog.value = 0;
        label.textContent = `0 / ${rows.length}`;
        loadBox.style.display = 'block';
        if (map) {
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
        }
        roughMin = 0;
        roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
        roughScales = {};
        rows.forEach(row => {
            const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
            s.min = Math.min(s.min, row.roughness);
            s.max = Math.max(s.max, row.roughness);
            roughScales[row.device_id] = s;
        });
        updateRoughnessLabels();
        for (let i = rows.length - 1; i >= 0; i--) {
            const row = rows[i];
            if (!filterRoughness(row.roughness)) continue;
            const name = deviceNicknames[row.device_id] || '';
            const scale = roughScales[row.device_id] || {min:0,max:1};
            addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
            prog.value = rows.length - i;
            label.textContent = `${rows.length - i} / ${rows.length}`;
            if ((rows.length - i) % 100 === 0) await new Promise(r => setTimeout(r, 0));
        }
        loadBox.style.display = 'none';
        addLog(`Total records loaded: ${rows.length}`);
        recordCount = rows.length;
    }).catch(err => console.error(err));
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', (event) => {
        if (event.accelerationIncludingGravity) {
            const acc = event.accelerationIncludingGravity;
            if (!motionDataReceived) {
                motionDataReceived = true;
                accelerationStatus = true;
                updateStatusIndicator('acceleration', true);
            }
            xValues.push(acc.x || 0);
            yValues.push(acc.y || 0);
            const zUpVal = zUp(acc);
            zValues.push(zUpVal);
            lastAcc = { x: acc.x || 0, y: acc.y || 0, z: zUpVal };
            updateStatus();
        }
    });
} else {
    accelerationStatus = false;
    updateStatusIndicator('acceleration', false, 'Device motion not supported');
}

function handlePosition(pos) {
    const { latitude, longitude, speed, heading } = pos.coords;
    lastLat = latitude;
    lastLon = longitude;
    lastSpeed = (speed || 0) * 3.6; // convert to km/h
    lastDir = heading || 0;
    
    // Update status indicator when GPS data is received
    locationStatus = true;
    updateStatusIndicator('location', true, 'GPS data received');

    // Update user location
    userLocation = [latitude, longitude];
    
    // Center map on user if option is selected
    const centerOnUser = document.getElementById('center-on-user').checked;
    if (centerOnUser && map) {
        map.setView(userLocation, map.getZoom());
    }
    
    updateStatus();
    addLog(`Location: ${latitude}, ${longitude} speed: ${lastSpeed.toFixed(1)} km/h`);
    if (loggingEnabled && zValues.length > 0) {
        const requestBody = {
            latitude,
            longitude,
            speed: lastSpeed,
            direction: lastDir,
            z_values: zValues,
            device_id: deviceId,
            user_agent: userAgent,
            device_fp: fingerprint,
            record_source_data: recordSourceData
        };
        
        fetch(LOG_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        }).then(r => r.json()).then(data => {
            if (data.roughness !== undefined) {
                lastRoughness = data.roughness;
                addLog(`Record inserted, roughness: ${data.roughness.toFixed(2)}`);
                updateStatus();
                const scale = roughScales[deviceId] || {min: data.roughness, max: data.roughness};
                if (filterRoughness(data.roughness)) {
                    addPoint(latitude, longitude, data.roughness, {
                        timestamp: new Date().toLocaleString('sv-SE', { timeZone: 'Europe/Amsterdam' }),
                        speed: lastSpeed,
                        direction: lastDir,
                        roughness: data.roughness
                    }, currentNickname, scale.min, scale.max);
                }
                scale.min = Math.min(scale.min, data.roughness);
                scale.max = Math.max(scale.max, data.roughness);
                roughScales[deviceId] = scale;
                recordCount += 1;
                
                // Center map on user location after adding point if option is selected
                if (centerOnUser && map && userLocation) {
                    map.setView(userLocation, map.getZoom());
                }
                // Do not reload all logs during active recording
            }
        }).catch(err => addDebug('Error: ' + err));
        xValues = [];
        yValues = [];
        zValues = [];
    }
}

function handleGeoError(err) {
    addDebug('Geolocation error: ' + err.message);
    locationStatus = false;
    updateStatusIndicator('location', false, `GPS error: ${err.message}`);
}

async function startGeolocation() {
    if (!navigator.geolocation) {
        addDebug('Geolocation not supported');
        locationStatus = false;
        updateStatusIndicator('location', false, 'Geolocation not supported');
        return;
    }
    motionDataReceived = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
    }
    requestMotionPermission();
    motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    if (geoWatchId === null) {
        geoWatchId = navigator.geolocation.watchPosition(
            handlePosition,
            handleGeoError,
            GEO_OPTIONS
        );
    }
    loggingEnabled = true;
    updateToggleButton();

    // Request wake lock when starting recording
    await requestWakeLock();
}

async function stopGeolocation() {
    loggingEnabled = false;
    updateToggleButton();
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
        motionPermissionTimer = null;
    }
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
    }
    
    // Release wake lock when stopping recording
    await releaseWakeLock();
}

function pollDebug() {
    fetch('/debuglog').then(r => r.json()).then(data => {
        document.getElementById('debug').value = data.log.join('\n');
    }).catch(console.error).finally(() => setTimeout(pollDebug, 10000));
}



updateStatus();
initMap();
populateDeviceFilter();
pollDebug();
// Initial status check
checkDatabaseStatus();
// Check database status periodically
setInterval(checkDatabaseStatus, 30000);

document.getElementById('toggle').addEventListener('click', async () => {
    if (loggingEnabled) {
        await stopGeolocation();
        addLog('Logging stopped');
    } else {
        await startGeolocation();
        addLog('Logging started');
    }
    updateToggleButton();
});

const updateBtn = document.getElementById('update-button');
if (updateBtn) {
    updateBtn.addEventListener('click', () => {
        addLog('Update Records pressed');
        loadLogs();
    });
}

// Only add nickname event listener if the elements exist
const saveNicknameBtn = document.getElementById('save-nickname');
if (saveNicknameBtn) {
    saveNicknameBtn.addEventListener('click', () => {
        addLog('Save Nickname pressed');
        saveNickname();
    });
}

document.getElementById('device-filter').addEventListener('change', () => {
    selectedIds = Array.from(document.getElementById('device-filter').selectedOptions)
        .map(o => o.value).filter(v => v);
    loadNickname();
    loadLogs();
});
document.getElementById('roughness-filter').addEventListener('change', () => {
    loadLogs();
});
document.getElementById('record-source-data').addEventListener('change', (e) => {
    recordSourceData = e.target.checked;
    addLog(`Source data recording ${recordSourceData ? 'enabled' : 'disabled'}`);
    localStorage.setItem('recordSourceData', recordSourceData);
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});



let wakeLock = null;
let wakeLockSupported = false;

async function requestWakeLock() {
    if (!('wakeLock' in navigator)) {
        addDebug('Wake Lock API not supported in this browser');
        updateWakeLockStatus();
        return false;
    }
    
    try {
        // Check if we already have an active wake lock
        if (wakeLock !== null && !wakeLock.released) {
            addDebug('Wake lock already active');
            return true;
        }
        
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLockSupported = true;
        
        wakeLock.addEventListener('release', async () => {
            addDebug('Wake lock released (may have been due to tab switch or battery saving)');
            updateWakeLockStatus();
            if (loggingEnabled) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    addDebug('Wake lock re-acquired automatically');
                    updateWakeLockStatus();
                } catch (err) {
                    addDebug('Failed to re-acquire wake lock: ' + err.message);
                }
            }
        });
        
        addDebug('Wake lock acquired - screen will stay on during recording');
        updateWakeLockStatus();
        return true;
    } catch (err) {
        if (err.name === 'NotAllowedError') {
            addDebug('Wake lock denied - user may need to grant permission');
        } else if (err.name === 'NotSupportedError') {
            addDebug('Wake lock not supported on this device');
        } else {
            addDebug('Wake lock error: ' + err.message);
        }
        updateWakeLockStatus();
        return false;
    }
}

async function releaseWakeLock() {
    if (wakeLock !== null) {
        try {
            await wakeLock.release();
            wakeLock = null;
            addDebug('Wake lock manually released - screen may turn off');
        } catch (err) {
            addDebug('Wake lock release error: ' + err.message);
        }
        updateWakeLockStatus();
    }
}

function updateWakeLockStatus() {
    const statusElement = document.getElementById('wake-lock-status');
    const manualButton = document.getElementById('manual-wake-lock');
    const indicator = document.getElementById('wakelock-indicator');
    const explanation = document.getElementById('wakelock-explanation');
    
    if (!statusElement) return;
    
    if (!('wakeLock' in navigator)) {
        statusElement.innerHTML = '‚ùå Wake Lock not supported in this browser';
        statusElement.style.color = 'red';
        if (manualButton) manualButton.disabled = true;
        if (indicator) {
            indicator.className = 'status-indicator status-red';
            explanation.textContent = 'Not supported';
        }
        return;
    }
    
    const isActive = wakeLock !== null && !wakeLock.released;
    
    if (isActive) {
        statusElement.innerHTML = 'üîÜ Screen locked on - won\'t turn off during recording';
        statusElement.style.color = 'green';
        if (indicator) {
            indicator.className = 'status-indicator status-green';
            explanation.textContent = 'Screen stays on';
        }
    } else {
        statusElement.innerHTML = 'üí§ Screen may turn off - tap "Toggle Wake Lock" to prevent';
        statusElement.style.color = 'orange';
        if (indicator) {
            indicator.className = 'status-indicator status-red';
            explanation.textContent = 'Screen may turn off';
        }
    }
    
    if (manualButton) {
        manualButton.textContent = isActive ? 'Release Wake Lock' : 'Request Wake Lock';
        manualButton.disabled = false;
    }
}

// Manual wake lock toggle
async function toggleWakeLock() {
    if (wakeLock !== null && !wakeLock.released) {
        await releaseWakeLock();
    } else {
        await requestWakeLock();
    }
}

// Initialize wake lock status display
updateWakeLockStatus();

// Add manual wake lock button event listener
document.getElementById('manual-wake-lock').addEventListener('click', toggleWakeLock);

// Re-request wake lock when page becomes visible again (only if recording)
if ('wakeLock' in navigator) {
    document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'visible' && loggingEnabled) {
            // Small delay to ensure the page is fully visible
            setTimeout(async () => {
                if (wakeLock === null || wakeLock.released) {
                    addDebug('Page became visible during recording - requesting wake lock');
                    await requestWakeLock();
                }
            }, 100);
        }
    });
    
    // Also handle page focus events for additional reliability
    window.addEventListener('focus', async () => {
        if (loggingEnabled && (wakeLock === null || wakeLock.released)) {
            addDebug('Window focused during recording - requesting wake lock');
            await requestWakeLock();
        }
    });
}

function toggleSettings() {
    const content = document.getElementById('settings-content');
    const toggle = document.getElementById('settings-toggle');
    
    if (content.style.display === 'none' || !content.style.display) {
        content.style.display = 'block';
        toggle.textContent = '‚ñ≤';
    } else {
        content.style.display = 'none';
        toggle.textContent = '‚ñº';
    }
}

function loadSettings() {
    fetch('/api/thresholds')
        .then(r => r.json())
        .then(data => {
            document.getElementById('max-interval').value = data.max_interval_sec;
            document.getElementById('max-distance').value = data.max_distance_m;
            document.getElementById('min-speed').value = data.min_speed_kmh;
            document.getElementById('freq-min').value = data.freq_min;
            document.getElementById('freq-max').value = data.freq_max;
        })
        .catch(err => {
            console.error('Failed to load settings:', err);
            addLog('Failed to load threshold settings');
        });
}

function saveSettings() {
    const settings = {
        max_interval_sec: parseFloat(document.getElementById('max-interval').value),
        max_distance_m: parseFloat(document.getElementById('max-distance').value),
        min_speed_kmh: parseFloat(document.getElementById('min-speed').value),
        freq_min: parseFloat(document.getElementById('freq-min').value),
        freq_max: parseFloat(document.getElementById('freq-max').value)
    };
    
    // Validate frequency range
    if (settings.freq_min >= settings.freq_max) {
        alert('Minimum frequency must be less than maximum frequency');
        return;
    }
    
    fetch('/api/thresholds', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
    })
    .then(r => {
        if (!r.ok) {
            return r.json().then(err => Promise.reject(err));
        }
        return r.json();
    })
    .then(data => {
        addLog('‚úÖ Threshold settings saved successfully');
        console.log('Settings saved:', data.thresholds);
    })
    .catch(err => {
        console.error('Failed to save settings:', err);
        addLog('‚ùå Failed to save threshold settings: ' + (err.detail || err.message || 'Unknown error'));
    });
}

function resetSettings() {
    if (confirm('Reset all threshold settings to default values?')) {
        // Default values from the backend
        document.getElementById('max-interval').value = 15;
        document.getElementById('max-distance').value = 100;
        document.getElementById('min-speed').value = 0;
        document.getElementById('freq-min').value = 0.5;
        document.getElementById('freq-max').value = 50;
        
        // Save the defaults
        saveSettings();
    }
}

</script>
<div id="roughness-info" style="margin-top:1rem; border:1px solid #ccc; padding:0.5rem; display:none;">
    <strong>Roughness Calculation</strong> - each acceleration sample is first rotated so that
    the device's Z axis aligns with the real-world up direction derived from the orientation
    angles. The resulting vertical values are filtered to keep vibrations between
    1&nbsp;and&nbsp;20&nbsp;Hz. The root-mean-square of this signal is divided by the average
    speed over the sample window. Records taken while travelling under
    5&nbsp;km/h are ignored.
</div>
<div id="roughness-scale" style="margin-top:1rem; font-size:0.9rem; display:none;">
    <strong>Roughness Scale Reference</strong>
    <ol style="column-count:2; padding-left:1.25rem;">
        <li>Smooth road</li>
        <li>Even surface</li>
        <li>Light texture</li>
        <li>Coarse texture</li>
        <li>Moderate roughness</li>
        <li>Bumpy cobbles</li>
        <li>Fine gravel</li>
        <li>Coarse gravel</li>
        <li>Severely uneven</li>
        <li>Extremely rough</li>
    </ol>
</div>
<div style="margin-top:1rem;">
    <button id="toggle-explanation" style="background:none; border:1px solid #ccc; padding:0.5rem; cursor:pointer; font-size:0.9rem; width:100%; text-align:left;">
        ‚ûï Show Roughness Explanation and Scale Reference
    </button>
</div>

<!-- Include Activity Log and Debug Messages Partial -->
<div id="logs-container"></div>

</body>
</html>
