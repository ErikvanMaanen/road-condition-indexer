<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Condition Indexer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
        #map { width: 100%; height: 20vh; margin-bottom: 1rem; }
        #map:fullscreen { width: 100%; height: 100%; }
        #status { margin-bottom: 1rem; font-weight: bold; }
        #button-bar { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input:disabled { opacity: 0.5; cursor: not-allowed; }
        #toggle { padding: 1rem 2rem; font-size: 1.25rem; }
        #scale-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }
        #scale-bar {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, green, yellow, red);
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<h1>Road Condition Indexer</h1>
<nav id="page-links" style="margin-bottom:1rem;">
    <a href="device.html">Device View</a>
</nav>
</body>
<!-- Hidden maintenance link as a square at bottom right -->
<a href="maintenance.html" id="maintenance-link" style="position:fixed;bottom:24px;right:24px;width:32px;height:32px;display:block;z-index:9999;opacity:0.2;background:#888;border-radius:6px;text-align:center;line-height:32px;text-decoration:none;font-size:1.5rem;transition:opacity 0.2s;" title="Maintenance">üõ†Ô∏è</a>
<script>
// Show the maintenance link on hover or focus
const maintLink = document.getElementById('maintenance-link');
maintLink.addEventListener('mouseenter',()=>maintLink.style.opacity='1');
maintLink.addEventListener('mouseleave',()=>maintLink.style.opacity='0.2');
maintLink.addEventListener('focus',()=>maintLink.style.opacity='1');
maintLink.addEventListener('blur',()=>maintLink.style.opacity='0.2');
</script>
<section id="filter-dev" style="margin-bottom:1rem;">
    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
        <select id="roughness-filter" multiple style="min-width:180px;">
            <option value="">[All Roughness]</option>
            <option value="1">1 - Smooth road</option>
            <option value="2">2 - Even surface</option>
            <option value="3">3 - Light texture</option>
            <option value="4">4 - Coarse texture</option>
            <option value="5">5 - Moderate roughness</option>
            <option value="6">6 - Bumpy cobbles</option>
            <option value="7">7 - Fine gravel</option>
            <option value="8">8 - Coarse gravel</option>
            <option value="9">9 - Severely uneven</option>
            <option value="10">10 - Extremely rough</option>
        </select>
        <select id="device-filter" multiple></select>
    </div>
</section>
<div id="map"></div>
<div id="scale-container">
    <span>Smooth</span>
    <div id="scale-bar"></div>
    <span>Rough</span>
</div>
<div style="margin-bottom:1rem;">
    <label>
        <input type="checkbox" id="center-on-user" checked> Keep map centered on my location
    </label>
</div>
<section id="controls" style="margin-bottom:1rem;">
    <div id="status"></div>
    <div id="wake-lock-status" style="font-size: 0.9rem; margin: 0.5rem 0;">üí§ Screen may turn off</div>
    <div id="button-bar">
        <button id="toggle">Start</button>
        <button id="update-button" style="margin-left:1rem; display:none;">Update Records</button>
    </div>
    <div id="loading" style="display:none; margin-top:1rem;">
        <progress id="load-progress" value="0" max="0" style="width:100%;"></progress>
        <span id="load-label"></span>
    </div>
</section>
<section id="logs" style="margin-bottom:1rem; display:none;">
    <h3>Activity Log</h3>
    <div id="log"></div>
    <h3>Debug Messages</h3>
    <textarea id="debug" readonly></textarea>
</section>
<div style="margin-bottom:1rem;">
    <button id="toggle-logs" onclick="toggleLogs()">Show Logs</button>
</div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let deviceId = localStorage.getItem('deviceId');
let selectedIds = deviceId ? [deviceId] : [];
function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 864e5).toUTCString();
    document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/`;
}
if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem('deviceId', deviceId);
    setCookie('deviceId', deviceId, 365);
}
const userAgent = navigator.userAgent;
const fingerprint = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    navigator.platform,
    new Date().getTimezoneOffset()
].join('|');
const LOG_ENDPOINT = '/log';

function loadNickname() {
    const nickInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('save-nickname');
    if (!nickInput || !saveBtn) {
        currentNickname = '';
        return;
    }
    if (selectedIds.length !== 1) {
        nickInput.value = '';
        nickInput.placeholder = selectedIds.length === 0 ? 'Device nickname' : 'Select single device to edit nickname';
        nickInput.disabled = true;
        saveBtn.disabled = true;
        currentNickname = '';
        return;
    }
    nickInput.disabled = false;
    saveBtn.disabled = false;
    nickInput.placeholder = 'Device nickname';
    const id = selectedIds[0];
    fetch(`/nickname?device_id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(data => {
            currentNickname = data.nickname || '';
            nickInput.value = currentNickname;
        })
        .catch(console.error);
}

function saveNickname() {
    const nickInput = document.getElementById('nickname');
    const saveBtn = document.getElementById('save-nickname');
    if (!nickInput || !saveBtn || selectedIds.length !== 1 || nickInput.disabled || saveBtn.disabled) return;
    const name = nickInput.value;
    fetch('/nickname', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_id: selectedIds[0], nickname: name })
    }).then(() => populateDeviceFilter())
      .catch(console.error);
}

function populateDeviceFilter() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const select = document.getElementById('device-filter');
        select.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        select.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            select.appendChild(opt);
        });
        if (deviceId && !data.ids.some(i => i.id === deviceId)) {
            const opt = document.createElement('option');
            opt.value = deviceId;
            opt.textContent = deviceId;
            select.appendChild(opt);
        }
        Array.from(select.options).forEach(o => {
            if (selectedIds.includes(o.value)) o.selected = true;
        });
        selectedIds = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
    }).then(() => { loadNickname(); loadLogs(); })
      .catch(console.error);
}
let xValues = [];
let yValues = [];
let zValues = [];
let lastLat = 0;
let lastLon = 0;
let lastSpeed = 0;
let lastDir = 0;
let lastRoughness = 0;
let lastAcc = {x:0, y:0, z:0};
let map;
let orientationData = {alpha:0, beta:0, gamma:0};
let roughMin = 0;
const LABEL_COUNT = 10;
const ROUGHNESS_NAMES = [
    'Smooth road',
    'Even surface',
    'Light texture',
    'Coarse texture',
    'Moderate roughness',
    'Bumpy cobbles',
    'Fine gravel',
    'Coarse gravel',
    'Severely uneven',
    'Extremely rough'
];
let roughMax = LABEL_COUNT;
let roughAvg = 0;
let roughScales = {};
let deviceNicknames = {};
let currentNickname = '';
let motionDataReceived = false;
let motionPermissionTimer = null;
let userLocation = null; // Store user's current location

function toggleLogs() {
    const logsSection = document.getElementById('logs');
    const toggleButton = document.getElementById('toggle-logs');
    
    if (logsSection.style.display === 'none') {
        logsSection.style.display = 'block';
        toggleButton.textContent = 'Hide Logs';
    } else {
        logsSection.style.display = 'none';
        toggleButton.textContent = 'Show Logs';
    }
}
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (event) => {
        if (event.beta !== null && event.gamma !== null) {
            orientationData = { alpha: event.alpha || 0, beta: event.beta, gamma: event.gamma };
        }
    });
}

function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
            .then(res => addDebug('Motion permission: ' + res))
            .catch(err => addDebug('Motion permission error: ' + err));
    }
}

function checkMotionPermission() {
    if (!motionDataReceived) {
        addDebug('No acceleration data received, requesting permission');
        requestMotionPermission();
        motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    }
}
const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
let geoWatchId = null;
let loggingEnabled = false;
let recordCount = 0;

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        () => addDebug('Geolocation permission granted'),
        err => addDebug('Geolocation permission denied: ' + err.message),
        GEO_OPTIONS
    );
}

function initMap() {
    const defaultPos = [52.028, 5.168]; // Houten, NL
    const zoom = 12;
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    
    const setView = coords => {
        userLocation = coords;
        map.setView(coords, zoom);
    };
    
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => {
                const coords = [pos.coords.latitude, pos.coords.longitude];
                setView(coords);
                addLog('Map centered on your location');
            },
            () => {
                setView(defaultPos);
                addLog('Using default location (Houten, NL)');
            },
            GEO_OPTIONS
        );
    } else {
        setView(defaultPos);
        addLog('Geolocation not supported, using default location');
    }
    addFullscreenControl(map);
}

function addFullscreenControl(m) {
    const Full = L.Control.extend({
        onAdd: function() {
            const btn = L.DomUtil.create('button', 'leaflet-bar');
            btn.textContent = '‚§¢';
            L.DomEvent.on(btn, 'click', () => {
                const el = m.getContainer();
                addLog('Fullscreen button pressed');
                if (!document.fullscreenElement) {
                    el.requestFullscreen?.();
                } else {
                    document.exitFullscreen?.();
                }
            });
            return btn;
        }
    });
    m.addControl(new Full({ position: 'topleft' }));
}

function addLog(msg) {
    const div = document.getElementById('log');
    div.textContent += msg + '\n';
    div.scrollTop = div.scrollHeight;
}

function updateStatus() {
    const el = document.getElementById('status');
    el.textContent =
        `Lat: ${lastLat.toFixed(5)}, Lon: ${lastLon.toFixed(5)} | ` +
        `Speed: ${lastSpeed.toFixed(1)} km/h | ` +
        `Dir: ${lastDir.toFixed(0)}\u00B0 | ` +
        `Acc: X: ${lastAcc.x.toFixed(2)} ` +
        `Y: ${lastAcc.y.toFixed(2)} ` +
        `Z: ${lastAcc.z.toFixed(2)} | ` +
        `Roughness: ${lastRoughness.toFixed(2)}`;
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const ratio = (Math.log(r + offset) - logMin) / (logMax - logMin);
    const idx = Math.max(0, Math.min(LABEL_COUNT - 1, Math.floor(ratio * LABEL_COUNT)));
    return String(idx + 1);
}

function roughnessRange(idx) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const low = Math.exp((logMax - logMin) * idx / LABEL_COUNT + logMin) - offset;
    const high = Math.exp((logMax - logMin) * (idx + 1) / LABEL_COUNT + logMin) - offset;
    return [low, high];
}

function updateRoughnessLabels() {
    const select = document.getElementById('roughness-filter');
    if (select) {
        for (let i = 0; i < LABEL_COUNT; i++) {
            const opt = select.options[i + 1];
            if (!opt) continue;
            const [low, high] = roughnessRange(i);
            opt.textContent = `${i + 1} - ${ROUGHNESS_NAMES[i]} (${low.toFixed(2)}-${high.toFixed(2)})`;
        }
    }
    const items = document.querySelectorAll('#roughness-scale ol li');
    items.forEach((li, idx) => {
        if (idx >= LABEL_COUNT) return;
        const [low, high] = roughnessRange(idx);
        li.textContent = `${ROUGHNESS_NAMES[idx]} (${low.toFixed(2)}-${high.toFixed(2)})`;
    });
}

function filterRoughness(r) {
    const sel = document.getElementById('roughness-filter');
    if (!sel) return true;
    const values = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (values.length === 0) return true;
    return values.includes(roughnessLabel(r));
}

function zUp(acc) {
    const beta = orientationData.beta * Math.PI / 180;
    const gamma = orientationData.gamma * Math.PI / 180;
    const gX = -Math.sin(beta);
    const gY = Math.cos(beta) * Math.sin(gamma);
    const gZ = Math.cos(beta) * Math.cos(gamma);
    const upX = -gX;
    const upY = -gY;
    const upZ = -gZ;
    const mag = Math.sqrt(upX*upX + upY*upY + upZ*upZ) || 1;
    return (acc.x * upX + acc.y * upY + acc.z * upZ) / mag;
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = new Date(info.timestamp).toLocaleString();
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
    if (info && info.id) {
        marker.on('click', () => {
            localStorage.setItem('selectedRecordId', info.id);
        });
    }
}

function loadLogs() {
    const select = document.getElementById('device-filter');
    const ids = Array.from(select.selectedOptions).map(o => o.value).filter(v => v);
    let url = '/logs';
    if (ids.length > 0) {
        const params = new URLSearchParams();
        ids.forEach(id => params.append('device_id', id));
        url = '/filteredlogs?' + params.toString();
    }
    fetch(url).then(r => r.json()).then(async data => {
        const rows = Array.isArray(data) ? data : data.rows;
        roughAvg = data.average || 0;
        const loadBox = document.getElementById('loading');
        const prog = document.getElementById('load-progress');
        const label = document.getElementById('load-label');
        prog.max = rows.length;
        prog.value = 0;
        label.textContent = `0 / ${rows.length}`;
        loadBox.style.display = 'block';
        if (map) {
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
        }
        roughMin = 0;
        roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
        roughScales = {};
        rows.forEach(row => {
            const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
            s.min = Math.min(s.min, row.roughness);
            s.max = Math.max(s.max, row.roughness);
            roughScales[row.device_id] = s;
        });
        updateRoughnessLabels();
        for (let i = rows.length - 1; i >= 0; i--) {
            const row = rows[i];
            if (!filterRoughness(row.roughness)) continue;
            const name = deviceNicknames[row.device_id] || '';
            const scale = roughScales[row.device_id] || {min:0,max:1};
            addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
            prog.value = rows.length - i;
            label.textContent = `${rows.length - i} / ${rows.length}`;
            if ((rows.length - i) % 100 === 0) await new Promise(r => setTimeout(r, 0));
        }
        loadBox.style.display = 'none';
        addLog(`Total records loaded: ${rows.length}`);
        recordCount = rows.length;
    }).catch(err => console.error(err));
}

function addDebug(msg) {
    const el = document.getElementById('debug');
    el.value += msg + '\n';
    el.scrollTop = el.scrollHeight;
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', (event) => {
        if (event.accelerationIncludingGravity) {
            const acc = event.accelerationIncludingGravity;
            motionDataReceived = true;
            xValues.push(acc.x || 0);
            yValues.push(acc.y || 0);
            const zUpVal = zUp(acc);
            zValues.push(zUpVal);
            lastAcc = { x: acc.x || 0, y: acc.y || 0, z: zUpVal };
            updateStatus();
        }
    });
}

function handlePosition(pos) {
    const { latitude, longitude, speed, heading } = pos.coords;
    lastLat = latitude;
    lastLon = longitude;
    lastSpeed = (speed || 0) * 3.6; // convert to km/h
    lastDir = heading || 0;
    
    // Update user location
    userLocation = [latitude, longitude];
    
    // Center map on user if option is selected
    const centerOnUser = document.getElementById('center-on-user').checked;
    if (centerOnUser && map) {
        map.setView(userLocation, map.getZoom());
    }
    
    updateStatus();
    addLog(`Location: ${latitude}, ${longitude} speed: ${lastSpeed.toFixed(1)} km/h`);
    if (loggingEnabled && zValues.length > 0) {
        fetch(LOG_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                latitude,
                longitude,
                speed: lastSpeed,
                direction: lastDir,
                z_values: zValues,
                device_id: deviceId,
                user_agent: userAgent,
                device_fp: fingerprint
            })
        }).then(r => r.json()).then(data => {
            if (data.roughness !== undefined) {
                lastRoughness = data.roughness;
                addLog(`Record inserted, roughness: ${data.roughness.toFixed(2)}`);
                updateStatus();
                const scale = roughScales[deviceId] || {min: data.roughness, max: data.roughness};
                if (filterRoughness(data.roughness)) {
                    addPoint(latitude, longitude, data.roughness, {
                        timestamp: new Date().toISOString(),
                        speed: lastSpeed,
                        direction: lastDir,
                        roughness: data.roughness
                    }, currentNickname, scale.min, scale.max);
                }
                scale.min = Math.min(scale.min, data.roughness);
                scale.max = Math.max(scale.max, data.roughness);
                roughScales[deviceId] = scale;
                recordCount += 1;
                
                // Center map on user location after adding point if option is selected
                if (centerOnUser && map && userLocation) {
                    map.setView(userLocation, map.getZoom());
                }
                // Do not reload all logs during active recording
            }
        }).catch(err => addDebug('Error: ' + err));
        xValues = [];
        yValues = [];
        zValues = [];
    }
}

function handleGeoError(err) {
    addDebug('Geolocation error: ' + err.message);
}

function startGeolocation() {
    if (!navigator.geolocation) {
        addDebug('Geolocation not supported');
        return;
    }
    motionDataReceived = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
    }
    requestMotionPermission();
    motionPermissionTimer = setTimeout(checkMotionPermission, 5000);
    if (geoWatchId === null) {
        geoWatchId = navigator.geolocation.watchPosition(
            handlePosition,
            handleGeoError,
            GEO_OPTIONS
        );
    }
    loggingEnabled = true;
    
    // Request wake lock when starting recording
    requestWakeLock();
}

function stopGeolocation() {
    loggingEnabled = false;
    if (motionPermissionTimer !== null) {
        clearTimeout(motionPermissionTimer);
        motionPermissionTimer = null;
    }
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
    }
    
    // Release wake lock when stopping recording
    releaseWakeLock();
}

function pollDebug() {
    fetch('/debuglog').then(r => r.json()).then(data => {
        document.getElementById('debug').value = data.log.join('\n');
    }).catch(console.error).finally(() => setTimeout(pollDebug, 2000));
}



updateStatus();
initMap();
populateDeviceFilter();
pollDebug();

document.getElementById('toggle').addEventListener('click', () => {
    if (loggingEnabled) {
        stopGeolocation();
        document.getElementById('toggle').textContent = 'Start';
        addLog('Logging stopped');
    } else {
        startGeolocation();
        document.getElementById('toggle').textContent = 'Stop';
        addLog('Logging started');
    }
});

const updateBtn = document.getElementById('update-button');
if (updateBtn) {
    updateBtn.addEventListener('click', () => {
        addLog('Update Records pressed');
        loadLogs();
    });
}
document.getElementById('save-nickname').addEventListener('click', () => {
    addLog('Save Nickname pressed');
    saveNickname();
});
document.getElementById('device-filter').addEventListener('change', () => {
    selectedIds = Array.from(document.getElementById('device-filter').selectedOptions)
        .map(o => o.value).filter(v => v);
    loadNickname();
    loadLogs();
});
document.getElementById('roughness-filter').addEventListener('change', () => {
    loadLogs();
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});

let wakeLock = null;

async function requestWakeLock() {
    if (!('wakeLock' in navigator)) {
        addDebug('Wake Lock API not supported');
        return false;
    }
    
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
            addDebug('Wake lock released');
            updateWakeLockStatus();
        });
        addDebug('Wake lock acquired - screen will stay on');
        updateWakeLockStatus();
        return true;
    } catch (err) {
        addDebug('Wake lock error: ' + err.message);
        updateWakeLockStatus();
        return false;
    }
}

async function releaseWakeLock() {
    if (wakeLock !== null) {
        try {
            await wakeLock.release();
            wakeLock = null;
            addDebug('Wake lock manually released');
        } catch (err) {
            addDebug('Wake lock release error: ' + err.message);
        }
        updateWakeLockStatus();
    }
}

function updateWakeLockStatus() {
    const statusElement = document.getElementById('wake-lock-status');
    if (statusElement) {
        const isActive = wakeLock !== null && !wakeLock.released;
        statusElement.textContent = isActive ? 'üîÜ Screen locked on' : 'üí§ Screen may turn off';
        statusElement.style.color = isActive ? 'green' : 'orange';
    }
}

// Initialize wake lock status display
updateWakeLockStatus();

// Re-request wake lock when page becomes visible again (only if recording)
if ('wakeLock' in navigator) {
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && loggingEnabled && (wakeLock === null || wakeLock.released)) {
            requestWakeLock();
        }
    });
}
</script>
<div id="roughness-info" style="margin-top:1rem; border:1px solid #ccc; padding:0.5rem;">
    <strong>Roughness Calculation</strong> - each acceleration sample is first rotated so that
    the device's Z axis aligns with the real-world up direction derived from the orientation
    angles. The resulting vertical values are filtered to keep vibrations between
    1&nbsp;and&nbsp;20&nbsp;Hz. The root-mean-square of this signal is divided by the average
    speed over the sample window. Records taken while travelling under
    5&nbsp;km/h are ignored.
</div>
<div id="roughness-scale" style="margin-top:1rem; font-size:0.9rem;">
    <strong>Roughness Scale Reference</strong>
    <ol style="column-count:2; padding-left:1.25rem;">
        <li>Smooth road</li>
        <li>Even surface</li>
        <li>Light texture</li>
        <li>Coarse texture</li>
        <li>Moderate roughness</li>
        <li>Bumpy cobbles</li>
        <li>Fine gravel</li>
        <li>Coarse gravel</li>
        <li>Severely uneven</li>
        <li>Extremely rough</li>
    </ol>
</div>
</body>
</html>
