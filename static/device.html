<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Records - Road Condition Indexer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="utils.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #controls { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; }
        #controls input { margin-right: 0.5rem; }
        #range-container { position:relative; height:30px; }
        #range-container input { position:absolute; left:0; right:0; width:100%; }
        #startRange { z-index:2; }
        #endRange { z-index:1; }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
<h1>Device Records</h1>
<nav id="page-links" style="margin-bottom:1rem;">
    <a href="/">Main</a>
</nav>
<!-- Hidden maintenance link as a square at bottom right -->
<a href="maintenance.html" id="maintenance-link" style="position:fixed;bottom:24px;right:24px;width:32px;height:32px;display:block;z-index:9999;opacity:0.2;background:#888;border-radius:6px;text-align:center;line-height:32px;text-decoration:none;font-size:1.5rem;transition:opacity 0.2s;" title="Maintenance">üõ†Ô∏è</a>
<script>
// Show the maintenance link on hover or focus
const maintLink = document.getElementById('maintenance-link');
maintLink.addEventListener('mouseenter',()=>maintLink.style.opacity='1');
maintLink.addEventListener('mouseleave',()=>maintLink.style.opacity='0.2');
maintLink.addEventListener('focus',()=>maintLink.style.opacity='1');
maintLink.addEventListener('blur',()=>maintLink.style.opacity='0.2');
</script>
<section id="filter-dev" style="margin-bottom:1rem;">
    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
        <select id="deviceId" multiple></select>
        <button id="rename-button" style="padding: 0.5rem;">Rename</button>
    </div>
    <div id="rename-section" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #ccc; background: #f5f5f5;">
        <input type="text" id="nickname-input" placeholder="Enter new nickname" style="margin-right: 0.5rem;">
        <button id="save-rename" style="margin-right: 0.5rem;">Save</button>
        <button id="cancel-rename">Cancel</button>
    </div>
</section>

<!-- Include standardized map component -->
<div id="map-container"></div>

<section id="filter-time" style="margin-bottom:1rem;">
    <input id="startDate" type="datetime-local">
    <input id="endDate" type="datetime-local">
    <div id="range-container" style="flex-basis:100%; position:relative; height:30px;">
        <input id="startRange" type="range" style="position:absolute;left:0;right:0;width:100%;">
        <input id="endRange" type="range" style="position:absolute;left:0;right:0;width:100%;">
    </div>
</section>
<section id="controls" style="margin-bottom:1rem;">
    <button id="gpx-button">Generate GPX</button>
    <a id="gpx-link" style="display:none;">Download GPX</a>
    <div id="loading" style="display:none; margin-top:1rem;">
        <progress id="load-progress" value="0" max="0" style="width:100%;"></progress>
        <span id="load-label"></span>
    </div>
</section>

<!-- Include Activity Log and Debug Messages Partial -->
<div id="logs-container"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const currentDeviceId = localStorage.getItem('deviceId');
// Make deviceId available globally for logs partial
window.deviceId = currentDeviceId;
let selectedIds = [];
let deviceNicknames = {};
let roughMin = 0;
// LABEL_COUNT is already defined in utils.js
// Using local ROUGHNESS_NAMES to override the ones from utils.js
const ROUGHNESS_NAMES_DEVICE = [
    'Smooth road',
    'Even surface',
    'Light texture',
    'Coarse texture',
    'Moderate roughness',
    'Bumpy cobbles',
    'Fine gravel',
    'Coarse gravel',
    'Severely uneven',
    'Extremely rough'
];
let roughMax = LABEL_COUNT;
let roughAvg = 0;
let roughScales = {};
let sliderMin = 0;
let sliderMax = 0;
const pageRefreshTime = Date.now();
let loadedRows = [];
let markers = [];

function populateDeviceIds() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const sel = document.getElementById('deviceId');
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        sel.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            sel.appendChild(opt);
        });
        if (currentDeviceId && !data.ids.some(i => i.id === currentDeviceId)) {
            const opt = document.createElement('option');
            opt.value = currentDeviceId;
            opt.textContent = currentDeviceId;
            sel.appendChild(opt);
        }
        Array.from(sel.options).forEach(o => {
            if (selectedIds.includes(o.value)) o.selected = true;
        });
        selectedIds = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    }).then(() =>
        setDateRange().then(() => {
            loadData();
        })
    ).catch(console.error);
}
</script>
<script>

function setDateRange() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    let url = '/date_range';
    if (ids.length > 0) {
        const params = new URLSearchParams();
        ids.forEach(id => params.append('device_id', id));
        url = '/date_range?' + params.toString();
    }
    return fetch(url).then(r => r.json()).then(data => {
        if (data.start) {
            document.getElementById('startDate').value = toCESTDateTimeLocal(data.start);
            sliderMin = Date.parse(data.start);
        }
        document.getElementById('endDate').value = toCESTDateTimeLocal(pageRefreshTime);
        sliderMax = pageRefreshTime;
        syncRanges();
    }).catch(console.error);
}

function syncRanges() {
    const startVal = Date.parse(document.getElementById('startDate').value);
    const endVal = Date.parse(document.getElementById('endDate').value);
    if (!isNaN(startVal) && !isNaN(endVal)) {
        const startR = document.getElementById('startRange');
        const endR = document.getElementById('endRange');
        startR.min = sliderMin; startR.max = sliderMax;
        endR.min = sliderMin; endR.max = sliderMax;
        startR.value = startVal; endR.value = endVal;
    }
}

function initMap() {
    const map = initializeStandardMap({
        center: [52.028, 5.168], // Houten, NL
        zoom: 12,
        enableGeolocation: true,
        enableBicycleMarker: false,
        enableFullscreen: true
    });
    
    // Initialize roughness filter
    initializeRoughnessFilter(() => {
        updateMarkers();
    });
}

// Load logs partial when DOM is ready
document.addEventListener('DOMContentLoaded', loadLogsPartial);

async function loadLogsPartial() {
    try {
        const logsContainer = document.getElementById('logs-container');
        if (!logsContainer) {
            console.error('Logs container not found');
            return false;
        }

        const response = await fetch('logs-partial.html');
        if (!response.ok) {
            throw new Error(`Failed to load logs-partial.html: ${response.status} ${response.statusText}`);
        }

        const logsHtml = await response.text();
        
        // Parse the HTML to extract script content
        const parser = new DOMParser();
        const doc = parser.parseFromString(logsHtml, 'text/html');
        
        // Insert the HTML content (excluding scripts)
        const scripts = doc.querySelectorAll('script');
        const styles = doc.querySelectorAll('style');
        
        // Remove scripts and styles from the content to insert them separately
        scripts.forEach(script => script.remove());
        styles.forEach(style => style.remove());
        
        // Insert the HTML content
        logsContainer.innerHTML = doc.body.innerHTML;
        
        // Insert and execute styles
        styles.forEach(style => {
            const newStyle = document.createElement('style');
            newStyle.textContent = style.textContent;
            document.head.appendChild(newStyle);
        });
        
        // Create a namespace for the logs partial to avoid variable collisions
        if (!window.logsPartialNamespace) {
            window.logsPartialNamespace = {};
            
            // Define toggleLogs in the global scope to make it accessible
            window.toggleLogs = function() {
                const logsSection = document.getElementById('logs');
                const toggleButton = document.getElementById('toggle-logs');
                
                if (logsSection && toggleButton) {
                    if (logsSection.style.display === 'none') {
                        logsSection.style.display = 'block';
                        toggleButton.textContent = 'Hide Logs';
                    } else {
                        logsSection.style.display = 'none';
                        toggleButton.textContent = 'Show Logs';
                    }
                }
            };
            
            // Add the necessary functions and variables from logs-partial.html
            window.addLog = function(message, category = 'UI', level = 'INFO') {
                const timestamp = new Date().toISOString();
                const deviceIdForLogs = window.deviceId || localStorage.getItem('deviceId') || '';
                const logMsg = {
                    timestamp,
                    message,
                    category,
                    level,
                    deviceId: deviceIdForLogs
                };
                
                // Add to log array and update display
                if (window.logsPartialNamespace.allLogMessages) {
                    window.logsPartialNamespace.allLogMessages.push(logMsg);
                    window.logsPartialNamespace.renderLogMessages();
                }
                
                return logMsg;
            };
            
            // Initialize rendering of logs
            window.logsPartialNamespace.allLogMessages = [];
            
            window.logsPartialNamespace.renderLogMessages = function() {
                const logsTable = document.getElementById('logs-table-body');
                if (!logsTable) return;
                
                // Clear existing rows
                logsTable.innerHTML = '';
                
                // Get the most recent messages (up to 100)
                const recentMessages = window.logsPartialNamespace.allLogMessages.slice(-100);
                
                // Create and append rows
                recentMessages.forEach(msg => {
                    const row = document.createElement('tr');
                    row.className = msg.level;
                    
                    const time = new Date(msg.timestamp).toLocaleTimeString();
                    
                    row.innerHTML = `
                        <td class="log-time">${time}</td>
                        <td class="log-level">${msg.level}</td>
                        <td class="log-category">${msg.category}</td>
                        <td class="log-message">${msg.message}</td>
                    `;
                    
                    logsTable.appendChild(row);
                });
                
                // Auto-scroll to bottom
                const logsContainer = document.getElementById('logs');
                if (logsContainer) {
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                }
            };
        }
        
        // Add a log message to indicate logs have been loaded
        if (typeof addLog === 'function') {
            addLog('Logs system initialized', 'System', 'INFO');
        }
        
        return true;
    } catch (error) {
        console.error('Failed to load logs partial:', error);
        if (typeof addDebug === 'function') {
            addDebug('Logs partial loading error: ' + error.message, 'System', 'ERROR');
        }
        return false;
    }
}

function generateGpx() {
    fetch('/gpx').then(r => r.blob()).then(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.getElementById('gpx-link');
        link.href = url;
        link.download = 'records.gpx';
        link.style.display = 'inline';
        link.textContent = 'Download GPX';
    }).catch(err => addDebug('GPX error: ' + err));
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const ratio = (Math.log(r + offset) - logMin) / (logMax - logMin);
    const idx = Math.max(0, Math.min(LABEL_COUNT - 1, Math.floor(ratio * LABEL_COUNT)));
    return String(idx + 1);
}

function roughnessRange(idx) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const low = Math.exp((logMax - logMin) * idx / LABEL_COUNT + logMin) - offset;
    const high = Math.exp((logMax - logMin) * (idx + 1) / LABEL_COUNT + logMin) - offset;
    return [low, high];
}

function updateRoughnessLabels() {
    const select = document.getElementById('roughness-filter');
    if (select) {
        for (let i = 0; i < LABEL_COUNT; i++) {
            const opt = select.options[i + 1];
            if (!opt) continue;
            const [low, high] = roughnessRange(i);
            opt.textContent = `${i + 1} - ${ROUGHNESS_NAMES_DEVICE[i]} (${low.toFixed(2)}-${high.toFixed(2)})`;
        }
    }
}

function filterRoughness(r) {
    const sel = document.getElementById('roughness-filter');
    if (!sel) return true;
    const values = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (values.length === 0) return true;
    return values.includes(roughnessLabel(r));
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!window.map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(window.map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = formatDutchTime(info.timestamp);
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
    return marker;
}

async function updateMarkers(showProgress = false) {
    // Make sure loadedRows is defined
    if (!Array.isArray(loadedRows)) {
        console.warn('loadedRows is not defined yet');
        loadedRows = [];
        return; // Don't try to update markers if we don't have data
    }

    const startVal = Date.parse(document.getElementById('startDate').value);
    const endVal = Date.parse(document.getElementById('endDate').value);
    const loadBox = document.getElementById('loading');
    const prog = document.getElementById('load-progress');
    const label = document.getElementById('load-label');
    
    if (showProgress) {
        loadBox.style.display = 'block';
        prog.max = loadedRows.length;
        prog.value = 0;
        label.textContent = `0 / ${loadedRows.length}`;
    }
    for (let i = loadedRows.length - 1; i >= 0; i--) {
        const row = loadedRows[i];
        const ts = Date.parse(row.timestamp);
        const within = (!isNaN(startVal) ? ts >= startVal : true) &&
                       (!isNaN(endVal) ? ts <= endVal : true) &&
                       filterRoughness(row.roughness);
        if (within) {
            if (!markers[i]) {
                const name = deviceNicknames[row.device_id] || '';
                const scale = roughScales[row.device_id] || {min:0,max:1};
                markers[i] = addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
            }
        } else if (markers[i]) {
            window.map.removeLayer(markers[i]);
            markers[i] = null;
        }
        if (showProgress) {
            prog.value = loadedRows.length - i;
            label.textContent = `${loadedRows.length - i} / ${loadedRows.length}`;
            if ((loadedRows.length - i) % 100 === 0) await new Promise(r => setTimeout(r, 0));
        }
    }
    if (showProgress) loadBox.style.display = 'none';
}

function loadData() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    const start = document.getElementById('startDate').value;
    const end = document.getElementById('endDate').value;
    const params = new URLSearchParams();
    ids.forEach(id => params.append('device_id', id));
    if (start) params.append('start', fromCESTDateTimeLocal(start));
    if (end) params.append('end', fromCESTDateTimeLocal(end));
    fetch('/filteredlogs?' + params.toString())
        .then(r => r.json())
        .then(async data => {
            markers.forEach(m => { if (m) window.map.removeLayer(m); });
            markers = [];
            loadedRows = data.rows || [];
            roughAvg = data.average || 0;
            roughMin = 0;
            roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
            roughScales = {};
            loadedRows.forEach(row => {
                const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
                s.min = Math.min(s.min, row.roughness);
                s.max = Math.max(s.max, row.roughness);
                roughScales[row.device_id] = s;
            });
            updateRoughnessLabels();
            await updateMarkers(true);
        })
        .catch(console.error);
}

// Authentication check - verify user is logged in
async function checkAuthentication() {
    try {
        const response = await fetch('/auth_check');
        if (!response.ok) {
            // Not authenticated, redirect to login
            window.location.href = '/static/login.html?next=' + encodeURIComponent(window.location.pathname);
            return false;
        }
        return true;
    } catch (error) {
        console.error('Authentication check failed:', error);
        // On error, assume not authenticated and redirect
        window.location.href = '/static/login.html?next=' + encodeURIComponent(window.location.pathname);
        return false;
    }
}

// Check authentication before initializing page
(async function() {
    const isAuthenticated = await checkAuthentication();
    if (!isAuthenticated) {
        return; // Will be redirected
    }
    
    // Only proceed with page initialization if authenticated
    initializePage();
})();

function initializePage() {
    // Load map partial using proper script execution
    loadMapPartial().then(mapLoaded => {
        if (mapLoaded) {
            // Wait for map functions to be available
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max
            
            function waitForMapFunctions() {
                return new Promise(resolve => {
                    const checkForFunctions = () => {
                        if (typeof initializeStandardMap === 'function' || attempts >= maxAttempts) {
                            resolve(typeof initializeStandardMap === 'function');
                        } else {
                            attempts++;
                            setTimeout(checkForFunctions, 100);
                        }
                    };
                    checkForFunctions();
                });
            }
            
            waitForMapFunctions().then(functionsLoaded => {
                if (functionsLoaded) {
                    initMap();
                } else {
                    console.warn('Map functions not loaded, using fallback');
                    createFallbackMap();
                }
                populateDeviceIds();
                syncRanges();
            });
        } else {
            console.warn('Map partial failed to load, using fallback');
            createFallbackMap();
            populateDeviceIds();
            syncRanges();
        }
    });
}

// Load map partial with proper script execution
async function loadMapPartial() {
    try {
        const response = await fetch('map-partial.html');
        const html = await response.text();
        
        // Parse HTML to properly handle scripts and styles
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Extract and apply styles
        const styles = doc.querySelectorAll('style');
        styles.forEach(style => {
            const newStyle = document.createElement('style');
            newStyle.textContent = style.textContent;
            document.head.appendChild(newStyle);
        });
        
        // Extract scripts for separate execution
        const scripts = doc.querySelectorAll('script');
        const scriptContents = Array.from(scripts).map(script => script.textContent);
        
        // Get HTML content without scripts
        const container = document.getElementById('map-container');
        container.innerHTML = doc.body.innerHTML;
        
        // Execute scripts after DOM is updated
        for (const scriptContent of scriptContents) {
            if (scriptContent.trim()) {
                const script = document.createElement('script');
                script.textContent = scriptContent;
                document.body.appendChild(script);
            }
        }
        
        return true;
    } catch (error) {
        console.error('Failed to load map partial:', error);
        return false;
    }
}

// Fallback map creation for device page
function createFallbackMap() {
    const mapContainer = document.getElementById('map-container');
    if (mapContainer) {
        mapContainer.innerHTML = `
            <div id="map" style="width: 100%; height: 40vh; margin-bottom: 1rem; border: 1px solid #ccc;"></div>
            <div id="scale-container" style="display: flex; align-items: center; margin-bottom: 1rem; gap: 0.5rem;">
                <span>Smooth</span>
                <div id="scale-bar" style="flex: 1; height: 12px; background: linear-gradient(to right, green, yellow, red); border: 1px solid #ccc;"></div>
                <span>Rough</span>
            </div>
        `;
        
        // Create basic map
        window.map = L.map('map');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(window.map);
        window.map.setView([52.028, 5.168], 12);
        
        // Add basic fullscreen control if available
        if (typeof addFullscreenControl === 'function') {
            addFullscreenControl(window.map);
        }
        
        // Basic functions for compatibility
        window.clearMapData = function() {
            if (window.map) {
                window.map.eachLayer(layer => {
                    if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                        window.map.removeLayer(layer);
                    }
                });
            }
        };
    }
}

// Move event listeners to after authentication check
document.addEventListener('DOMContentLoaded', async () => {
    const isAuthenticated = await checkAuthentication();
    if (!isAuthenticated) {
        return;
    }
    
    // Add event listeners only if authenticated
    document.getElementById('deviceId').addEventListener('change', () => {
        selectedIds = Array.from(document.getElementById('deviceId').selectedOptions)
            .map(o => o.value).filter(v => v);
        setDateRange().then(loadData);
    });
    
    document.getElementById('gpx-button').addEventListener('click', () => {
        addLog('Generate GPX pressed');
        generateGpx();
    });
    
    let sliderUpdating = false;
    document.getElementById('startDate').addEventListener('change', () => {
        if (sliderUpdating) return;
        syncRanges();
        updateMarkers();
    });
    
    document.getElementById('endDate').addEventListener('change', () => {
        if (sliderUpdating) return;
        syncRanges();
        updateMarkers();
    });
    
    document.getElementById('startRange').addEventListener('input', () => {
        sliderUpdating = true;
        const v = parseInt(document.getElementById('startRange').value, 10);
        document.getElementById('startDate').value = toCESTDateTimeLocal(v);
        syncRanges();
        updateMarkers();
        sliderUpdating = false;
    });
    
    document.getElementById('endRange').addEventListener('input', () => {
        sliderUpdating = true;
        const v = parseInt(document.getElementById('endRange').value, 10);
        document.getElementById('endDate').value = toCESTDateTimeLocal(v);
        syncRanges();
        updateMarkers();
        sliderUpdating = false;
    });

    // Rename functionality
    document.getElementById('rename-button').addEventListener('click', () => {
        const selectedDevices = Array.from(document.getElementById('deviceId').selectedOptions);
        if (selectedDevices.length !== 1) {
            alert('Please select exactly one device to rename.');
            return;
        }
        
        const deviceId = selectedDevices[0].value;
        const currentNickname = deviceNicknames[deviceId] || '';
        
        document.getElementById('nickname-input').value = currentNickname;
        document.getElementById('rename-section').style.display = 'block';
        document.getElementById('nickname-input').focus();
    });

    document.getElementById('save-rename').addEventListener('click', () => {
        const selectedDevices = Array.from(document.getElementById('deviceId').selectedOptions);
        if (selectedDevices.length !== 1) {
            document.getElementById('rename-section').style.display = 'none';
            return;
        }
        
        const deviceId = selectedDevices[0].value;
        // Validate that we have a valid device ID before making the request
        if (!deviceId || deviceId.trim() === '') {
            console.error('Cannot save nickname: invalid device ID');
            document.getElementById('rename-section').style.display = 'none';
            return;
        }
        
        const nickname = document.getElementById('nickname-input').value.trim();
        
        fetch('/nickname', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ device_id: deviceId, nickname: nickname })
        })
        .then(response => response.json())
        .then(() => {
            document.getElementById('rename-section').style.display = 'none';
            
            // Update local nickname without reloading all devices
            deviceNicknames[deviceId] = nickname;
            
            // Update the device option in the select dropdown
            const select = document.getElementById('deviceId');
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === deviceId) {
                    select.options[i].textContent = nickname ? `${nickname} (${deviceId})` : deviceId;
                    break;
                }
            }
            
            // Update markers on the map with the new nickname
            updateMarkers();
        })
        .catch(error => {
            console.error('Error saving nickname:', error);
            alert('Failed to save nickname. Please try again.');
        });
    });

    document.getElementById('cancel-rename').addEventListener('click', () => {
        document.getElementById('rename-section').style.display = 'none';
        document.getElementById('nickname-input').value = '';
    });

    // Allow Enter key to save rename
    document.getElementById('nickname-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('save-rename').click();
        }
    });

    // Load logs partial when DOM is ready  
    loadLogsPartial();
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});
</script>

<!-- Include Activity Log and Debug Messages Partial -->
<div id="logs-container"></div>

</body>
</html>
