<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Records</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap">
    <link rel="stylesheet" href="style.css">
    <meta name="theme-color" content="#6200ee">
</head>
<body class="device-page">
<h1>Device Records</h1>
<p><a href="/">Back to Main</a></p>
<div id="controls">
    <select id="deviceId"></select>
    <input id="startDate" type="datetime-local">
    <input id="endDate" type="datetime-local">
    <input id="nickname" placeholder="Nickname">
    <button id="save-nickname">Save</button>
    <button id="load">Load</button>
    <button id="fullscreen-button">Fullscreen</button>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
let map;
let deviceNicknames = {};
let currentNickname = '';
let roughMin = 0;
let roughMax = 10;
let roughAvg = 0;
let roughScales = {};

function populateDeviceIds() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const sel = document.getElementById('deviceId');
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        sel.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            sel.appendChild(opt);
        });
    }).then(() => { setDateRange(); loadNickname(); }).catch(console.error);
}

function setDateRange() {
    const device = document.getElementById('deviceId').value;
    const url = device ? `/date_range?device_id=${encodeURIComponent(device)}` : '/date_range';
    fetch(url).then(r => r.json()).then(data => {
        if (data.start) document.getElementById('startDate').value = data.start.slice(0,19);
        if (data.end) document.getElementById('endDate').value = data.end.slice(0,19);
    }).catch(console.error);
}

function loadNickname() {
    const device = document.getElementById('deviceId').value;
    if (!device) {
        document.getElementById('nickname').value = '';
        currentNickname = '';
        return;
    }
    fetch(`/nickname?device_id=${encodeURIComponent(device)}`)
        .then(r => r.json())
        .then(data => {
            currentNickname = data.nickname || '';
            document.getElementById('nickname').value = currentNickname;
        })
        .catch(console.error);
}

function saveNickname() {
    const device = document.getElementById('deviceId').value;
    const name = document.getElementById('nickname').value;
    if (!device) return;
    fetch('/nickname', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_id: device, nickname: name })
    }).then(() => populateDeviceIds())
      .catch(console.error);
}

function initMap() {
    const defaultPos = [52.028, 5.168]; // Houten, NL
    const zoom = 12;
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    const setView = coords => map.setView(coords, zoom);
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => setView([pos.coords.latitude, pos.coords.longitude]),
            () => setView(defaultPos),
            { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
        );
    } else {
        setView(defaultPos);
    }
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    if (roughAvg > 0) {
        if (r < roughAvg * 0.5) return 'Very smooth';
        if (r < roughAvg * 0.8) return 'Smooth';
        if (r < roughAvg * 1.2) return 'Moderate';
        if (r < roughAvg * 1.5) return 'Rough';
        return 'Very rough';
    }
    if (roughMax !== roughMin) {
        const step = (roughMax - roughMin) / 5;
        if (r < roughMin + step) return 'Very smooth';
        if (r < roughMin + step * 2) return 'Smooth';
        if (r < roughMin + step * 3) return 'Moderate';
        if (r < roughMin + step * 4) return 'Rough';
        return 'Very rough';
    }
    if (r < 1) return 'Very smooth';
    if (r < 2) return 'Smooth';
    if (r < 3) return 'Moderate';
    if (r < 4) return 'Rough';
    return 'Very rough';
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = new Date(info.timestamp).toLocaleString();
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
}

function loadData() {
    const device = document.getElementById('deviceId').value;
    const start = document.getElementById('startDate').value;
    const end = document.getElementById('endDate').value;
    const params = new URLSearchParams();
    if (device) params.append('device_id', device);
    if (start) params.append('start', start);
    if (end) params.append('end', end);
    fetch('/filteredlogs?' + params.toString())
        .then(r => r.json())
        .then(data => {
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
            roughAvg = data.average || 0;
            roughMin = 0;
            roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
            roughScales = {};
            data.rows.forEach(row => {
                const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
                s.min = Math.min(s.min, row.roughness);
                s.max = Math.max(s.max, row.roughness);
                roughScales[row.device_id] = s;
            });
            data.rows.reverse().forEach(row => {
                const name = deviceNicknames[row.device_id] || '';
                const scale = roughScales[row.device_id] || {min:0,max:1};
                addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
            });
        })
        .catch(console.error);
}

initMap();
populateDeviceIds();
document.getElementById('load').addEventListener('click', loadData);
document.getElementById('deviceId').addEventListener('change', () => {
    setDateRange();
    loadNickname();
});
document.getElementById('save-nickname').addEventListener('click', saveNickname);
document.getElementById('fullscreen-button').addEventListener('click', () => {
    const el = document.getElementById('map');
    if (!document.fullscreenElement) {
        if (el.requestFullscreen) {
            el.requestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});
</script>
</body>
</html>
