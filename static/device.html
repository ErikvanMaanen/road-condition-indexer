<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Records</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; margin: 0 auto; padding: 1rem; max-width: 800px; }
        #controls { margin-bottom: 1rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
        button { padding: 0.5rem 1rem; font-size: 1rem; }
        #map { width: 100%; height: 60vh; margin-top: 1rem; }
        #map:fullscreen { width: 100%; height: 100%; }
        #controls input { margin-right: 0.5rem; }
        #range-container { position:relative; height:30px; }
        #range-container input { position:absolute; left:0; right:0; width:100%; }
        #startRange { z-index:2; }
        #endRange { z-index:1; }
        #scale-container {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
            gap: 0.5rem;
        }
        #scale-bar {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, green, yellow, red);
            border: 1px solid #ccc;
        }
        #log {
            width: 100%;
            height: 150px;
            overflow: auto;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            white-space: pre;
        }
        #debug {
            width: 100%;
            height: 150px;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
<h1>Device Records</h1>
<nav id="page-links" style="margin-bottom:1rem;">
    <a href="/">Main</a> |
    <a href="db.html">DB Page</a> |
    <a href="maintenance.html">Maintenance</a>
</nav>
<section id="filter-dev" style="margin-bottom:1rem;">
    <select id="deviceId" multiple></select>
    <select id="roughness-filter" multiple>
        <option value="">[All Roughness]</option>
        <option value="1">1 - Smooth road</option>
        <option value="2">2 - Even surface</option>
        <option value="3">3 - Light texture</option>
        <option value="4">4 - Coarse texture</option>
        <option value="5">5 - Moderate roughness</option>
        <option value="6">6 - Bumpy cobbles</option>
        <option value="7">7 - Fine gravel</option>
        <option value="8">8 - Coarse gravel</option>
        <option value="9">9 - Severely uneven</option>
        <option value="10">10 - Extremely rough</option>
    </select>
</section>
<section id="filter-time" style="margin-bottom:1rem;">
    <input id="startDate" type="datetime-local">
    <input id="endDate" type="datetime-local">
    <div id="range-container" style="flex-basis:100%; position:relative; height:30px;">
        <input id="startRange" type="range" style="position:absolute;left:0;right:0;width:100%;">
        <input id="endRange" type="range" style="position:absolute;left:0;right:0;width:100%;">
    </div>
</section>
<div id="map"></div>
<div id="scale-container">
    <span>Smooth</span>
    <div id="scale-bar"></div>
    <span>Rough</span>
</div>
<section id="controls" style="margin-bottom:1rem;">
    <input id="nickname" placeholder="Nickname">
    <button id="save-nickname">Save</button>
    <button id="load">Load</button>
    <button id="gpx-button">Generate GPX</button>
    <a id="gpx-link" style="display:none;">Download GPX</a>
    <div id="loading" style="display:none; margin-top:1rem;">
        <progress id="load-progress" value="0" max="0" style="width:100%;"></progress>
        <span id="load-label"></span>
    </div>
</section>
<section id="logs" style="margin-bottom:1rem;">
    <h3>Activity Log</h3>
    <div id="log"></div>
    <h3>Debug Messages</h3>
    <textarea id="debug" readonly></textarea>
</section>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const currentDeviceId = localStorage.getItem('deviceId');
let selectedIds = currentDeviceId ? [currentDeviceId] : [];
let map;
let deviceNicknames = {};
let currentNickname = '';
let roughMin = 0;
const LABEL_COUNT = 10;
const ROUGHNESS_NAMES = [
    'Smooth road',
    'Even surface',
    'Light texture',
    'Coarse texture',
    'Moderate roughness',
    'Bumpy cobbles',
    'Fine gravel',
    'Coarse gravel',
    'Severely uneven',
    'Extremely rough'
];
let roughMax = LABEL_COUNT;
let roughAvg = 0;
let roughScales = {};
let sliderMin = 0;
let sliderMax = 0;

function populateDeviceIds() {
    fetch('/device_ids').then(r => r.json()).then(data => {
        const sel = document.getElementById('deviceId');
        sel.innerHTML = '';
        const optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = '[All Devices]';
        sel.appendChild(optAll);
        deviceNicknames = {};
        data.ids.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            if (item.nickname) deviceNicknames[item.id] = item.nickname;
            opt.textContent = item.nickname ? `${item.nickname} (${item.id})` : item.id;
            sel.appendChild(opt);
        });
        if (currentDeviceId && !data.ids.some(i => i.id === currentDeviceId)) {
            const opt = document.createElement('option');
            opt.value = currentDeviceId;
            opt.textContent = currentDeviceId;
            sel.appendChild(opt);
        }
        Array.from(sel.options).forEach(o => {
            if (selectedIds.includes(o.value)) o.selected = true;
        });
        selectedIds = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    }).then(() => { setDateRange(); loadNickname(); }).catch(console.error);
}

function setDateRange() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    let url = '/date_range';
    if (ids.length > 0) {
        const params = new URLSearchParams();
        ids.forEach(id => params.append('device_id', id));
        url = '/date_range?' + params.toString();
    }
    return fetch(url).then(r => r.json()).then(data => {
        if (data.start) document.getElementById('startDate').value = data.start.slice(0,19);
        if (data.end) document.getElementById('endDate').value = data.end.slice(0,19);
        sliderMin = Date.parse(data.start);
        sliderMax = Date.parse(data.end);
        syncRanges();
    }).catch(console.error);
}

function loadNickname() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (ids.length !== 1) {
        document.getElementById('nickname').value = '';
        currentNickname = '';
        return;
    }
    const id = ids[0];
    fetch(`/nickname?device_id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(data => {
            currentNickname = data.nickname || '';
            document.getElementById('nickname').value = currentNickname;
        })
        .catch(console.error);
}

function syncRanges() {
    const startVal = Date.parse(document.getElementById('startDate').value);
    const endVal = Date.parse(document.getElementById('endDate').value);
    if (!isNaN(startVal) && !isNaN(endVal)) {
        const startR = document.getElementById('startRange');
        const endR = document.getElementById('endRange');
        startR.min = sliderMin; startR.max = sliderMax;
        endR.min = sliderMin; endR.max = sliderMax;
        startR.value = startVal; endR.value = endVal;
    }
}

function saveNickname() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    const name = document.getElementById('nickname').value;
    if (ids.length !== 1) return;
    fetch('/nickname', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_id: ids[0], nickname: name })
    }).then(() => populateDeviceIds())
      .catch(console.error);
}

function initMap() {
    const defaultPos = [52.028, 5.168]; // Houten, NL
    const zoom = 12;
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    const setView = coords => map.setView(coords, zoom);
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            pos => setView([pos.coords.latitude, pos.coords.longitude]),
            () => setView(defaultPos),
            { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
        );
    } else {
        setView(defaultPos);
    }
    addFullscreenControl(map);
}

function addFullscreenControl(m) {
    const Full = L.Control.extend({
        onAdd: function() {
            const btn = L.DomUtil.create('button', 'leaflet-bar');
            btn.textContent = 'â¤¢';
            L.DomEvent.on(btn, 'click', () => {
                const el = m.getContainer();
                addLog('Fullscreen button pressed');
                if (!document.fullscreenElement) {
                    el.requestFullscreen?.();
                } else {
                    document.exitFullscreen?.();
                }
            });
            return btn;
        }
    });
    m.addControl(new Full({position:'topleft'}));
}

function addLog(msg) {
    const div = document.getElementById('log');
    if (div) {
        div.textContent += msg + '\n';
        div.scrollTop = div.scrollHeight;
    }
}

function addDebug(msg) {
    const el = document.getElementById('debug');
    if (el) {
        el.value += msg + '\n';
        el.scrollTop = el.scrollHeight;
    }
}

function generateGpx() {
    fetch('/gpx').then(r => r.blob()).then(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.getElementById('gpx-link');
        link.href = url;
        link.download = 'records.gpx';
        link.style.display = 'inline';
        link.textContent = 'Download GPX';
    }).catch(err => addDebug('GPX error: ' + err));
}

function colorForRoughness(r, min, max) {
    let ratio = 0;
    if (typeof min === 'number' && typeof max === 'number' && max !== min) {
        ratio = (r - min) / (max - min);
    } else if (roughAvg > 0) {
        ratio = r / (roughAvg * 2);
    } else if (roughMax !== roughMin) {
        ratio = (r - roughMin) / (roughMax - roughMin);
    }
    ratio = Math.min(Math.max(ratio, 0), 1);
    const red = Math.floor(255 * ratio);
    const green = Math.floor(255 * (1 - ratio));
    return `rgb(${red},${green},0)`;
}

function directionToCompass(deg) {
    if (deg === null || isNaN(deg)) return 'N/A';
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return directions[idx];
}

function roughnessLabel(r) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const ratio = (Math.log(r + offset) - logMin) / (logMax - logMin);
    const idx = Math.max(0, Math.min(LABEL_COUNT - 1, Math.floor(ratio * LABEL_COUNT)));
    return String(idx + 1);
}

function roughnessRange(idx) {
    let min = roughMin;
    let max = roughMax;
    if (max === min) {
        if (roughAvg > 0) {
            min = 0;
            max = roughAvg * 2;
        } else {
            max = min + LABEL_COUNT;
        }
    }
    const offset = 1;
    let logMin = Math.log(min + offset);
    let logMax = Math.log(max + offset);
    if (logMax === logMin) logMax = logMin + 1;
    const low = Math.exp((logMax - logMin) * idx / LABEL_COUNT + logMin) - offset;
    const high = Math.exp((logMax - logMin) * (idx + 1) / LABEL_COUNT + logMin) - offset;
    return [low, high];
}

function updateRoughnessLabels() {
    const select = document.getElementById('roughness-filter');
    if (select) {
        for (let i = 0; i < LABEL_COUNT; i++) {
            const opt = select.options[i + 1];
            if (!opt) continue;
            const [low, high] = roughnessRange(i);
            opt.textContent = `${i + 1} - ${ROUGHNESS_NAMES[i]} (${low.toFixed(2)}-${high.toFixed(2)})`;
        }
    }
}

function filterRoughness(r) {
    const sel = document.getElementById('roughness-filter');
    if (!sel) return true;
    const values = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    if (values.length === 0) return true;
    return values.includes(roughnessLabel(r));
}

function addPoint(lat, lon, roughness, info = null, nickname = '', min = null, max = null) {
    if (!map || (lat === 0 && lon === 0)) return;
    const opts = {
        color: colorForRoughness(roughness, min, max),
        radius: 4,
        weight: 1,
        opacity: 0.9,
        fillOpacity: 0.9
    };
    const marker = L.circleMarker([lat, lon], opts).addTo(map);
    let popup = `Roughness: ${roughnessLabel(roughness)} (${roughness.toFixed(2)})`;
    if (nickname) popup = `Device: ${nickname}<br>` + popup;
    if (info) {
        const timeStr = new Date(info.timestamp).toLocaleString();
        popup = `Time: ${timeStr}<br>` +
                `Speed: ${info.speed.toFixed(1)} km/h<br>` +
                `Dir: ${directionToCompass(info.direction)}<br>` +
                `Roughness: ${roughnessLabel(info.roughness)} (${info.roughness.toFixed(2)})`;
        if (nickname) popup = `Device: ${nickname}<br>` + popup;
    }
    marker.bindPopup(popup);
}

function loadData() {
    const sel = document.getElementById('deviceId');
    const ids = Array.from(sel.selectedOptions).map(o => o.value).filter(v => v);
    const start = document.getElementById('startDate').value;
    const end = document.getElementById('endDate').value;
    const params = new URLSearchParams();
    ids.forEach(id => params.append('device_id', id));
    if (start) params.append('start', start);
    if (end) params.append('end', end);
    fetch('/filteredlogs?' + params.toString())
        .then(r => r.json())
        .then(async data => {
            const loadBox = document.getElementById('loading');
            const prog = document.getElementById('load-progress');
            const label = document.getElementById('load-label');
            const rows = data.rows || [];
            prog.max = rows.length;
            prog.value = 0;
            label.textContent = `0 / ${rows.length}`;
            loadBox.style.display = 'block';
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                    map.removeLayer(layer);
                }
            });
            roughAvg = data.average || 0;
            roughMin = 0;
            roughMax = roughAvg > 0 ? roughAvg * 2 : 1;
            roughScales = {};
            rows.forEach(row => {
                const s = roughScales[row.device_id] || {min: row.roughness, max: row.roughness};
                s.min = Math.min(s.min, row.roughness);
                s.max = Math.max(s.max, row.roughness);
                roughScales[row.device_id] = s;
            });
            updateRoughnessLabels();
            for (let i = rows.length - 1; i >= 0; i--) {
                const row = rows[i];
                if (!filterRoughness(row.roughness)) continue;
                const name = deviceNicknames[row.device_id] || '';
                const scale = roughScales[row.device_id] || {min:0,max:1};
                addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
                prog.value = rows.length - i;
                label.textContent = `${rows.length - i} / ${rows.length}`;
                if ((rows.length - i) % 100 === 0) await new Promise(r => setTimeout(r, 0));
            }
            loadBox.style.display = 'none';
        })
        .catch(console.error);
}

initMap();
populateDeviceIds();
syncRanges();
document.getElementById('load').addEventListener('click', () => {
    addLog('Load pressed');
    loadData();
});
document.getElementById('deviceId').addEventListener('change', () => {
    selectedIds = Array.from(document.getElementById('deviceId').selectedOptions)
        .map(o => o.value).filter(v => v);
    setDateRange().then(loadData);
    loadNickname();
});
document.getElementById('roughness-filter').addEventListener('change', loadData);
document.getElementById('save-nickname').addEventListener('click', () => {
    addLog('Save Nickname pressed');
    saveNickname();
});
document.getElementById('gpx-button').addEventListener('click', () => {
    addLog('Generate GPX pressed');
    generateGpx();
});
let sliderUpdating = false;
document.getElementById('startDate').addEventListener('change', () => {
    if (sliderUpdating) return;
    syncRanges();
    loadData();
});
document.getElementById('endDate').addEventListener('change', () => {
    if (sliderUpdating) return;
    syncRanges();
    loadData();
});
document.getElementById('startRange').addEventListener('input', () => {
    sliderUpdating = true;
    const v = parseInt(document.getElementById('startRange').value, 10);
    document.getElementById('startDate').value = new Date(v).toISOString().slice(0,16);
    syncRanges();
    loadData();
    sliderUpdating = false;
});
document.getElementById('endRange').addEventListener('input', () => {
    sliderUpdating = true;
    const v = parseInt(document.getElementById('endRange').value, 10);
    document.getElementById('endDate').value = new Date(v).toISOString().slice(0,16);
    syncRanges();
    loadData();
    sliderUpdating = false;
});

document.addEventListener('fullscreenchange', () => {
    if (map) {
        map.invalidateSize();
    }
});
</script>
</body>
</html>
