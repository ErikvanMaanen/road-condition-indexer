<!-- Map Component Partial -->
<!-- This partial provides standardized map initialization and includes the roughness filter -->

<div id="map"></div>
<div id="scale-container">
    <span>Smooth</span>
    <div id="scale-bar"></div>
    <span>Rough</span>
</div>

<!-- Roughness Filter Component -->
<div id="roughness-filter-container" class="mb-05">
    <label for="roughness-range" class="text-sm mr-05">Roughness:</label>
    <div class="range-filter">
        <input type="range" id="roughness-min" min="1" max="10" value="1">
        <span class="text-sm">to</span>
        <input type="range" id="roughness-max" min="1" max="10" value="10">
        <button id="roughness-reset" type="button" class="ml-05 text-sm">All</button>
    </div>
    <div class="range-display">
        <span id="roughness-display">1-10 (All)</span>
    </div>
</div>

<!-- Time Filter Component -->
<div id="time-filter-container" class="mb-1">
    <div class="time-range-controls">
        <div class="time-input-group">
            <label for="startDate">Start Date & Time:</label>
            <input id="startDate" type="datetime-local">
        </div>
        <div class="time-input-group">
            <label for="endDate">End Date & Time:</label>
            <input id="endDate" type="datetime-local">
        </div>
        <div>
            <button id="applyTimeRange" class="apply-time-btn">Apply Range</button>
        </div>
    </div>
    
    <div class="time-range-container">
        <div class="time-range-slider" id="timeRangeSlider">
            <div class="time-range-track">
                <div class="time-range-fill" id="timeRangeFill"></div>
            </div>
            <div class="time-range-handle start" id="startHandle" data-handle="start"></div>
            <div class="time-range-handle end" id="endHandle" data-handle="end"></div>
        </div>
        <div class="time-range-labels">
            <span id="minTimeLabel">No data</span>
            <div class="time-range-info" id="rangeInfo">Select time range</div>
            <span id="maxTimeLabel">available</span>
        </div>
    </div>
    
    <div class="quick-time-buttons">
        <button class="quick-time-btn" data-range="today">Today</button>
        <button class="quick-time-btn" data-range="yesterday">Yesterday</button>
        <button class="quick-time-btn" data-range="last7days">Last 7 Days</button>
        <button class="quick-time-btn" data-range="last30days">Last 30 Days</button>
        <button class="quick-time-btn" data-range="thisweek">This Week</button>
        <button class="quick-time-btn" data-range="thismonth">This Month</button>
        <button class="quick-time-btn" data-range="all">All Data</button>
    </div>
</div>

<script>
/**
 * Standardized Map Initialization
 * @param {Object} options - Configuration options
 * @param {Array} options.center - [lat, lon] center coordinates (default: Houten, NL)
 * @param {number} options.zoom - Initial zoom level (default: 15)
 * @param {boolean} options.enableGeolocation - Enable automatic geolocation (default: true)
 * @param {boolean} options.enableBicycleMarker - Enable bicycle marker for user tracking (default: false)
 * @param {boolean} options.enableFullscreen - Add fullscreen control (default: true)
 * @param {string} options.attribution - Map attribution text
 * @param {Function} options.onLocationFound - Callback when location is found
 * @param {Function} options.onLocationError - Callback when location fails
 * @returns {L.Map} Leaflet map instance
 */
function initializeStandardMap(options = {}) {
    const defaults = {
        center: [52.028, 5.168], // Houten, NL
        zoom: 15,
        enableGeolocation: true,
        enableBicycleMarker: false,
        enableFullscreen: true,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        onLocationFound: null,
        onLocationError: null
    };
    
    const config = { ...defaults, ...options };
    
    // Initialize map
    const map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: config.attribution
    }).addTo(map);
    
    // Set initial view
    map.setView(config.center, config.zoom);
    
    // Store map globally (legacy compatibility)
    window.map = map;
    
    // Add fullscreen control if enabled
    if (config.enableFullscreen && typeof addFullscreenControl === 'function') {
        addFullscreenControl(map);
    }
    
    // Handle geolocation if enabled
    if (config.enableGeolocation && navigator.geolocation) {
        const geoOptions = {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
        };
        
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const coords = [position.coords.latitude, position.coords.longitude];
                map.setView(coords, config.zoom);
                
                // Handle bicycle marker for user tracking
                if (config.enableBicycleMarker) {
                    createBicycleMarker(map, coords);
                }
                
                // Custom callback
                if (config.onLocationFound) {
                    config.onLocationFound(coords, position);
                }
                
                // Log success
                if (typeof addLog === 'function') {
                    addLog('Map centered on your location');
                }
            },
            (error) => {
                // Fallback to default location
                map.setView(config.center, config.zoom);
                
                // Custom callback
                if (config.onLocationError) {
                    config.onLocationError(error);
                }
                
                // Log error
                if (typeof addLog === 'function') {
                    addLog(`GPS error: ${error.message}, using default location`);
                }
            },
            geoOptions
        );
    }
    
    // Force map to refresh after initialization
    setTimeout(() => {
        if (map) {
            map.invalidateSize();
        }
    }, 100);
    
    // Add fullscreen change listener to handle map resize
    document.addEventListener('fullscreenchange', () => {
        if (map) {
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        }
    });
    
    return map;
}

/**
 * Create and manage bicycle marker for user tracking
 * @param {L.Map} map - Leaflet map instance
 * @param {Array} coords - [lat, lon] initial coordinates
 * @returns {L.Marker} Bicycle marker
 */
function createBicycleMarker(map, coords) {
    // Create bicycle icon using SVG
    const bicycleIcon = L.divIcon({
        html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="blue" class="bicycle-pulse">
                <circle cx="6" cy="17" r="3" stroke="black" stroke-width="1"/>
                <circle cx="18" cy="17" r="3" stroke="black" stroke-width="1"/>
                <path d="M8 11l8-4 2 4M6 15l5-9 2 6h6" stroke="black" stroke-width="1.5" fill="none"/>
               </svg>`,
        className: 'bicycle-marker',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
    });
    
    // Create and add bicycle marker
    const bicycleMarker = L.marker(coords, { icon: bicycleIcon }).addTo(map);
    bicycleMarker.bindPopup("You are here");
    
    // Store globally for updates
    window.bicycleMarker = bicycleMarker;
    window.userLocation = coords;
    
    return bicycleMarker;
}

/**
 * Update bicycle marker position and popup
 * @param {Array} coords - [lat, lon] new coordinates
 * @param {Object} info - Additional information (speed, direction, etc.)
 */
function updateBicycleMarker(coords, info = {}) {
    if (window.bicycleMarker) {
        window.bicycleMarker.setLatLng(coords);
        window.userLocation = coords;
        
        // Update popup with additional info
        if (info.speed !== undefined || info.direction !== undefined) {
            let popup = "You are here";
            if (info.speed !== undefined) {
                popup += `<br>Speed: ${info.speed.toFixed(1)} km/h`;
            }
            if (info.direction !== undefined && typeof directionToCompass === 'function') {
                popup += `<br>Direction: ${directionToCompass(info.direction)}`;
            }
            window.bicycleMarker.setPopupContent(popup);
        }
        
        // Center map on user if enabled
        if (window.map && document.getElementById('center-on-user')?.checked) {
            window.map.setView(coords, window.map.getZoom());
        }
    }
}

/**
 * Clear all data points from the map
 */
function clearMapData() {
    if (window.map) {
        window.map.eachLayer(layer => {
            if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                window.map.removeLayer(layer);
            }
        });
    }
}

/**
 * Filter visible markers on the map based on roughness
 * @param {number} minRoughness - Minimum roughness to show
 * @param {number} maxRoughness - Maximum roughness to show
 */
function filterMapMarkers(minRoughness, maxRoughness) {
    if (!window.map) {
        console.log('filterMapMarkers: No map available');
        return;
    }
    
    console.log('filterMapMarkers called with:', { minRoughness, maxRoughness });
    
    let hiddenCount = 0;
    let visibleCount = 0;
    
    // Handle device.html style markers array (indexed array with loadedRows)
    if (window.markers && Array.isArray(window.markers) && window.loadedRows && Array.isArray(window.loadedRows)) {
        console.log('Using device.html style filtering with', window.loadedRows.length, 'rows and', window.markers.length, 'markers');
        
        for (let i = 0; i < window.loadedRows.length; i++) {
            const row = window.loadedRows[i];
            const marker = window.markers[i];
            
            if (row && typeof row.roughness === 'number') {
                const roughness = row.roughness;
                const shouldShow = roughness >= minRoughness && roughness <= maxRoughness;
                
                if (shouldShow) {
                    if (!marker && row.latitude && row.longitude) {
                        // Create marker if it doesn't exist and should be shown
                        const name = window.deviceNicknames?.[row.device_id] || '';
                        const scale = window.roughScales?.[row.device_id] || {min:0,max:1};
                        const newMarker = addPoint(row.latitude, row.longitude, row.roughness, row, name, scale.min, scale.max);
                        if (newMarker) {
                            window.markers[i] = newMarker;
                            visibleCount++;
                        }
                    } else if (marker && !window.map.hasLayer(marker)) {
                        // Show existing marker
                        window.map.addLayer(marker);
                        visibleCount++;
                    } else if (marker) {
                        visibleCount++;
                    }
                } else {
                    if (marker && window.map.hasLayer(marker)) {
                        // Hide marker
                        window.map.removeLayer(marker);
                        hiddenCount++;
                    } else if (marker) {
                        hiddenCount++;
                    }
                }
            }
        }
    } else {
        // Handle other pages - filter markers directly on the map
        window.map.eachLayer(layer => {
            if (layer instanceof L.CircleMarker && layer.roughnessValue !== undefined) {
                const roughness = layer.roughnessValue;
                if (roughness >= minRoughness && roughness <= maxRoughness) {
                    if (!window.map.hasLayer(layer)) {
                        window.map.addLayer(layer);
                    }
                    layer._isFiltered = false;
                    visibleCount++;
                } else {
                    if (window.map.hasLayer(layer)) {
                        window.map.removeLayer(layer);
                    }
                    layer._isFiltered = true;
                    hiddenCount++;
                }
            }
        });
        
        // Also check stored markers array for other pages
        if (window.markers && Array.isArray(window.markers)) {
            window.markers.forEach(marker => {
                if (marker && marker.roughnessValue !== undefined) {
                    const roughness = marker.roughnessValue;
                    if (roughness >= minRoughness && roughness <= maxRoughness) {
                        if (!window.map.hasLayer(marker)) {
                            window.map.addLayer(marker);
                        }
                        marker._isFiltered = false;
                        visibleCount++;
                    } else {
                        if (window.map.hasLayer(marker)) {
                            window.map.removeLayer(marker);
                        }
                        marker._isFiltered = true;
                        hiddenCount++;
                    }
                }
            });
        }
    }
    
    // Log filtering results if logging is available
    console.log('Filter results:', { visibleCount, hiddenCount });
    if (typeof addLog === 'function') {
        addLog(`Filter applied: ${visibleCount} markers visible, ${hiddenCount} hidden`);
    }
}

/**
 * Enhanced clear function that also clears stored markers
 */
function clearAllMapData() {
    if (window.map) {
        // Clear all markers from map
        const layersToRemove = [];
        window.map.eachLayer(layer => {
            if (layer instanceof L.CircleMarker || layer instanceof L.Polyline) {
                layersToRemove.push(layer);
            }
        });
        layersToRemove.forEach(layer => window.map.removeLayer(layer));
        
        // Clear any stored marker arrays
        if (window.markers && Array.isArray(window.markers)) {
            window.markers.length = 0;
        }
        if (window.mapMarkers && Array.isArray(window.mapMarkers)) {
            window.mapMarkers.length = 0;
        }
    }
}

/**
 * Initialize roughness filter functionality
 * @param {Function} onFilterChange - Callback when filter changes
 */
function initializeRoughnessFilter(onFilterChange) {
    const minSlider = document.getElementById('roughness-min');
    const maxSlider = document.getElementById('roughness-max');
    const resetBtn = document.getElementById('roughness-reset');
    const display = document.getElementById('roughness-display');
    
    if (minSlider && maxSlider) {
        const updateFilter = () => {
            let min = parseInt(minSlider.value);
            let max = parseInt(maxSlider.value);
            
            // Debug logging
            console.log('Filter update triggered:', { min, max });
            
            // Ensure min <= max
            if (min > max) {
                if (event.target === minSlider) {
                    maxSlider.value = min;
                    max = min;
                } else {
                    minSlider.value = max;
                    min = max;
                }
            }
            
            // Update display
            if (min === 1 && max === 10) {
                display.textContent = '1-10 (All)';
            } else if (min === max) {
                display.textContent = `${min}`;
            } else {
                display.textContent = `${min}-${max}`;
            }
            
            // Store current filter values globally
            window.currentRoughnessFilter = { min, max };
            
            // Apply filter to existing markers immediately
            filterMapMarkers(min, max);
            
            // Call the filter callback with range
            if (onFilterChange) {
                onFilterChange({ min, max });
            }
            
            // Only call heavy update functions if we have no data loaded yet or if specifically requested
            // This prevents unnecessary full reloads when we can just filter existing markers
            const hasLoadedData = (window.loadedRows && window.loadedRows.length > 0) || 
                                  (window.markers && window.markers.length > 0);
            
            if (!hasLoadedData) {
                // Try common map update functions used across different pages
                if (typeof updateMarkers === 'function') {
                    updateMarkers();
                } else if (typeof loadData === 'function') {
                    loadData();
                } else if (typeof loadLogs === 'function') {
                    loadLogs();
                } else if (typeof loadMapData === 'function') {
                    loadMapData();
                } else if (typeof refreshMapData === 'function') {
                    refreshMapData();
                }
            }
        };
        
        const resetFilter = () => {
            minSlider.value = 1;
            maxSlider.value = 10;
            updateFilter();
        };
        
        minSlider.addEventListener('input', updateFilter);
        maxSlider.addEventListener('input', updateFilter);
        if (resetBtn) {
            resetBtn.addEventListener('click', resetFilter);
        }
        
        // Initial update
        updateFilter();
    }
}

/**
 * Get current roughness filter values
 * @returns {Object} Current filter range {min, max}
 */
function getCurrentRoughnessFilter() {
    return window.currentRoughnessFilter || { min: 1, max: 10 };
}

/**
 * Check if a roughness value passes the current filter
 * @param {number} roughness - Roughness value to check
 * @returns {boolean} True if value passes filter
 */
function passesRoughnessFilter(roughness) {
    const filter = getCurrentRoughnessFilter();
    const value = parseInt(roughness);
    return value >= filter.min && value <= filter.max;
}

/**
 * Enhanced marker creation that stores roughness for filtering
 * @param {L.CircleMarker} marker - The marker to enhance
 * @param {number} roughness - Roughness value to store
 * @returns {L.CircleMarker} The enhanced marker
 */
function enhanceMarkerForFiltering(marker, roughness) {
    if (marker && typeof roughness === 'number') {
        marker.roughnessValue = roughness;
    }
    return marker;
}

/**
 * Create a map marker with roughness filtering support
 * @param {Array} coords - [lat, lng] coordinates 
 * @param {Object} options - Marker options
 * @param {number} roughness - Roughness value for filtering
 * @returns {L.CircleMarker} Enhanced marker
 */
function createFilterableMarker(coords, options, roughness) {
    const marker = L.circleMarker(coords, options);
    return enhanceMarkerForFiltering(marker, roughness);
}

// Export functions to global scope
window.initializeStandardMap = initializeStandardMap;
window.createBicycleMarker = createBicycleMarker;
window.updateBicycleMarker = updateBicycleMarker;
window.clearMapData = clearMapData;
window.clearAllMapData = clearAllMapData;
window.filterMapMarkers = filterMapMarkers;
window.initializeRoughnessFilter = initializeRoughnessFilter;
window.getCurrentRoughnessFilter = getCurrentRoughnessFilter;
window.passesRoughnessFilter = passesRoughnessFilter;
window.enhanceMarkerForFiltering = enhanceMarkerForFiltering;
window.createFilterableMarker = createFilterableMarker;

// Time Range Slider Implementation
const timeRangeSlider = {
    slider: null,
    startHandle: null,
    endHandle: null,
    fill: null,
    minTimeLabel: null,
    maxTimeLabel: null,
    rangeInfo: null,
    startDate: null,
    endDate: null,
    applyBtn: null,
    
    minTime: null,
    maxTime: null,
    currentStart: null,
    currentEnd: null,
    
    isDragging: false,
    activeHandle: null,
    
    init() {
        console.log('Initializing time range slider...');
        
        this.slider = document.getElementById('timeRangeSlider');
        this.startHandle = document.getElementById('startHandle');
        this.endHandle = document.getElementById('endHandle');
        this.fill = document.getElementById('timeRangeFill');
        this.minTimeLabel = document.getElementById('minTimeLabel');
        this.maxTimeLabel = document.getElementById('maxTimeLabel');
        this.rangeInfo = document.getElementById('rangeInfo');
        this.startDate = document.getElementById('startDate');
        this.endDate = document.getElementById('endDate');
        this.applyBtn = document.getElementById('applyTimeRange');
        
        if (!this.slider) {
            console.log('Time range slider elements not found');
            return;
        }
        
        this.setupEventListeners();
        this.updateTimeRange();
    },
    
    setupEventListeners() {
        // Handle dragging
        this.startHandle.addEventListener('mousedown', (e) => this.startDrag(e, 'start'));
        this.endHandle.addEventListener('mousedown', (e) => this.startDrag(e, 'end'));
        
        // Touch events for mobile
        this.startHandle.addEventListener('touchstart', (e) => this.startDrag(e, 'start'));
        this.endHandle.addEventListener('touchstart', (e) => this.startDrag(e, 'end'));
        
        // Global mouse/touch events
        document.addEventListener('mousemove', (e) => this.drag(e));
        document.addEventListener('mouseup', () => this.endDrag());
        document.addEventListener('touchmove', (e) => this.drag(e));
        document.addEventListener('touchend', () => this.endDrag());
        
        // Click on slider track
        this.slider.addEventListener('click', (e) => this.handleTrackClick(e));
        
        // Date input changes
        this.startDate.addEventListener('change', () => this.handleDateInputChange());
        this.endDate.addEventListener('change', () => this.handleDateInputChange());
        
        // Apply button
        this.applyBtn.addEventListener('click', () => this.applyTimeRange());
        
        // Quick time buttons
        document.querySelectorAll('.quick-time-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.handleQuickTime(e.target.dataset.range));
        });
    },
    
    startDrag(e, handle) {
        e.preventDefault();
        this.isDragging = true;
        this.activeHandle = handle;
        
        const handleElement = handle === 'start' ? this.startHandle : this.endHandle;
        handleElement.classList.add('active');
        
        document.body.style.userSelect = 'none';
    },
    
    drag(e) {
        if (!this.isDragging || !this.minTime || !this.maxTime) return;
        
        e.preventDefault();
        
        const rect = this.slider.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const percentage = Math.max(0, Math.min(1, (x - 10) / (rect.width - 20)));
        
        const timeRange = this.maxTime - this.minTime;
        const selectedTime = this.minTime + (percentage * timeRange);
        
        if (this.activeHandle === 'start') {
            this.currentStart = Math.min(selectedTime, this.currentEnd);
        } else {
            this.currentEnd = Math.max(selectedTime, this.currentStart);
        }
        
        this.updateVisuals();
        this.updateDateInputs();
    },
    
    endDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        
        const handleElement = this.activeHandle === 'start' ? this.startHandle : this.endHandle;
        handleElement.classList.remove('active');
        
        this.activeHandle = null;
        document.body.style.userSelect = '';
        
        // Trigger filtering
        this.applyTimeFilter();
    },
    
    handleTrackClick(e) {
        if (this.isDragging || !this.minTime || !this.maxTime) return;
        
        const rect = this.slider.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = Math.max(0, Math.min(1, (x - 10) / (rect.width - 20)));
        
        const timeRange = this.maxTime - this.minTime;
        const selectedTime = this.minTime + (percentage * timeRange);
        
        // Move the closest handle
        const startDistance = Math.abs(selectedTime - this.currentStart);
        const endDistance = Math.abs(selectedTime - this.currentEnd);
        
        if (startDistance < endDistance) {
            this.currentStart = Math.min(selectedTime, this.currentEnd);
        } else {
            this.currentEnd = Math.max(selectedTime, this.currentStart);
        }
        
        this.updateVisuals();
        this.updateDateInputs();
        this.applyTimeFilter();
    },
    
    updateVisuals() {
        if (!this.minTime || !this.maxTime) return;
        
        const timeRange = this.maxTime - this.minTime;
        const startPercentage = ((this.currentStart - this.minTime) / timeRange) * 100;
        const endPercentage = ((this.currentEnd - this.minTime) / timeRange) * 100;
        
        // Update handle positions
        this.startHandle.style.left = `${10 + (startPercentage / 100) * (this.slider.offsetWidth - 20)}px`;
        this.endHandle.style.left = `${10 + (endPercentage / 100) * (this.slider.offsetWidth - 20)}px`;
        
        // Update fill
        this.fill.style.left = `${startPercentage}%`;
        this.fill.style.width = `${endPercentage - startPercentage}%`;
        
        // Update range info
        const startStr = this.formatDateTime(this.currentStart);
        const endStr = this.formatDateTime(this.currentEnd);
        this.rangeInfo.textContent = `${startStr} - ${endStr}`;
    },
    
    updateDateInputs() {
        if (!this.currentStart || !this.currentEnd) return;
        
        const startLocal = this.toAmsterdamTime(this.currentStart);
        const endLocal = this.toAmsterdamTime(this.currentEnd);
        
        this.startDate.value = startLocal.slice(0, 16); // Remove seconds
        this.endDate.value = endLocal.slice(0, 16);
    },
    
    handleDateInputChange() {
        const startVal = this.startDate.value;
        const endVal = this.endDate.value;
        
        if (startVal && endVal) {
            const startTime = this.fromAmsterdamTime(startVal + ':00');
            const endTime = this.fromAmsterdamTime(endVal + ':00');
            
            if (startTime <= endTime && startTime >= this.minTime && endTime <= this.maxTime) {
                this.currentStart = startTime;
                this.currentEnd = endTime;
                this.updateVisuals();
            }
        }
    },
    
    applyTimeRange() {
        this.handleDateInputChange();
        this.applyTimeFilter();
    },
    
    handleQuickTime(range) {
        // Remove active class from all buttons
        document.querySelectorAll('.quick-time-btn').forEach(btn => btn.classList.remove('active'));
        
        // Add active class to clicked button
        event.target.classList.add('active');
        
        const now = new Date();
        const amsterdamNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Amsterdam"}));
        
        let start, end;
        
        switch (range) {
            case 'today':
                start = new Date(amsterdamNow);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                end.setHours(23, 59, 59, 999);
                break;
                
            case 'yesterday':
                start = new Date(amsterdamNow);
                start.setDate(start.getDate() - 1);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                end.setDate(end.getDate() - 1);
                end.setHours(23, 59, 59, 999);
                break;
                
            case 'last7days':
                start = new Date(amsterdamNow);
                start.setDate(start.getDate() - 7);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                break;
                
            case 'last30days':
                start = new Date(amsterdamNow);
                start.setDate(start.getDate() - 30);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                break;
                
            case 'thisweek':
                start = new Date(amsterdamNow);
                const dayOfWeek = start.getDay();
                const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                start.setDate(start.getDate() - daysFromMonday);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                break;
                
            case 'thismonth':
                start = new Date(amsterdamNow);
                start.setDate(1);
                start.setHours(0, 0, 0, 0);
                end = new Date(amsterdamNow);
                break;
                
            case 'all':
                if (this.minTime && this.maxTime) {
                    start = new Date(this.minTime);
                    end = new Date(this.maxTime);
                } else {
                    return;
                }
                break;
                
            default:
                return;
        }
        
        // Convert to UTC for internal use
        this.currentStart = start.getTime();
        this.currentEnd = end.getTime();
        
        this.updateVisuals();
        this.updateDateInputs();
        this.applyTimeFilter();
    },
    
    updateTimeRange() {
        // This function should be called when new data is loaded
        // For now, we'll set some reasonable defaults
        console.log('Updating time range...');
        
        const now = new Date();
        const yesterday = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
        this.minTime = yesterday.getTime();
        this.maxTime = now.getTime();
        this.currentStart = this.minTime;
        this.currentEnd = this.maxTime;
        
        this.minTimeLabel.textContent = this.formatDateTime(this.minTime);
        this.maxTimeLabel.textContent = this.formatDateTime(this.maxTime);
        
        this.updateVisuals();
        this.updateDateInputs();
    },
    
    applyTimeFilter() {
        console.log(`Applying time filter: ${new Date(this.currentStart)} to ${new Date(this.currentEnd)}`);
        
        // Call the filtering function if it exists
        if (typeof window.filterMapMarkers === 'function') {
            window.filterMapMarkers();
        }
        
        // Trigger custom event for other components
        window.dispatchEvent(new CustomEvent('timeRangeChanged', {
            detail: {
                start: this.currentStart,
                end: this.currentEnd
            }
        }));
    },
    
    formatDateTime(timestamp) {
        const date = new Date(timestamp);
        const amsterdam = new Date(date.toLocaleString("en-US", {timeZone: "Europe/Amsterdam"}));
        
        const year = amsterdam.getFullYear();
        const month = String(amsterdam.getMonth() + 1).padStart(2, '0');
        const day = String(amsterdam.getDate()).padStart(2, '0');
        const hours = String(amsterdam.getHours()).padStart(2, '0');
        const minutes = String(amsterdam.getMinutes()).padStart(2, '0');
        
        return `${day}/${month}/${year} ${hours}:${minutes}`;
    },
    
    toAmsterdamTime(timestamp) {
        const date = new Date(timestamp);
        const amsterdam = new Date(date.toLocaleString("en-US", {timeZone: "Europe/Amsterdam"}));
        
        const year = amsterdam.getFullYear();
        const month = String(amsterdam.getMonth() + 1).padStart(2, '0');
        const day = String(amsterdam.getDate()).padStart(2, '0');
        const hours = String(amsterdam.getHours()).padStart(2, '0');
        const minutes = String(amsterdam.getMinutes()).padStart(2, '0');
        const seconds = String(amsterdam.getSeconds()).padStart(2, '0');
        
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
    },
    
    fromAmsterdamTime(timeString) {
        // Parse the local time string and convert to UTC timestamp
        const localDate = new Date(timeString);
        
        // Get the offset for Amsterdam time zone
        const amsterdamOffset = this.getAmsterdamOffset(localDate);
        
        // Subtract the offset to get UTC
        return localDate.getTime() - (amsterdamOffset * 60 * 1000);
    },
    
    getAmsterdamOffset(date) {
        // Get the offset for Amsterdam timezone
        const utc1 = date.getTime() + (date.getTimezoneOffset() * 60000);
        const utc2 = new Date(utc1 + (3600000 * 1)); // +1 hour for CET
        
        // Check if DST is in effect (CEST = +2 hours)
        const amsterdam = new Date(date.toLocaleString("en-US", {timeZone: "Europe/Amsterdam"}));
        const utc = new Date(date.toLocaleString("en-US", {timeZone: "UTC"}));
        
        return (amsterdam.getTime() - utc.getTime()) / (1000 * 60);
    },
    
    getCurrentTimeRange() {
        return {
            start: this.currentStart,
            end: this.currentEnd
        };
    },
    
    setTimeRange(minTime, maxTime, currentStart = null, currentEnd = null) {
        this.minTime = minTime;
        this.maxTime = maxTime;
        this.currentStart = currentStart || minTime;
        this.currentEnd = currentEnd || maxTime;
        
        this.minTimeLabel.textContent = this.formatDateTime(this.minTime);
        this.maxTimeLabel.textContent = this.formatDateTime(this.maxTime);
        
        this.updateVisuals();
        this.updateDateInputs();
    }
};

// Initialize time range slider function
function initializeTimeRangeSlider() {
    console.log('Initializing time range slider...');
    
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            timeRangeSlider.init();
        });
    } else {
        timeRangeSlider.init();
    }
}

// Export time range functions to global scope
window.timeRangeSlider = timeRangeSlider;
window.initializeTimeRangeSlider = initializeTimeRangeSlider;
</script>

<!-- Styles removed: now consolidated in site.css -->
